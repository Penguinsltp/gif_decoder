fn main {
  let args = @sys.get_cli_args()
  
  if args.length() < 2 {
    println("ğŸ¨ GIFè§£ç å™¨ - ä½¿ç”¨è¯´æ˜")
    println("==================================================")
    println("ç”¨æ³•: moon run src/main <gifæ–‡ä»¶è·¯å¾„>")
    println("ç¤ºä¾‹: moon run src/main gif/__Attack.gif")
    println("      moon run src/main /path/to/your/image.gif")
    println("")
    println("ğŸ”§ å¦‚æœä¸æä¾›æ–‡ä»¶è·¯å¾„ï¼Œå°†è¿è¡Œå®Œæ•´çš„æ¼”ç¤ºç¨‹åº...")
    println("")
    
    // è¿è¡Œå®Œæ•´æ¼”ç¤º
    run_full_demo()
  } else {
    let gif_path = args[1]
    println("ğŸ¨ GIFè§£ç å™¨ - æ–‡ä»¶åˆ†æ")
    println("==================================================")
    
    // è§£ææŒ‡å®šçš„GIFæ–‡ä»¶
    analyze_gif_file(gif_path)
  }
}

///| åˆ†ææŒ‡å®šçš„GIFæ–‡ä»¶
fn analyze_gif_file(gif_path: String) -> Unit {
  println("ğŸ“‚ ç›®æ ‡æ–‡ä»¶: " + gif_path)
  println("--------------------------------------------------")
  
  // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
  if !@fs.path_exists(gif_path) {
    println("âŒ é”™è¯¯: æ–‡ä»¶ä¸å­˜åœ¨")
    println("   è¯·æ£€æŸ¥æ–‡ä»¶è·¯å¾„æ˜¯å¦æ­£ç¡®")
    return
  }
  
  // æ£€æŸ¥æ˜¯å¦ä¸ºæ–‡ä»¶
  try {
    if !@fs.is_file(gif_path) {
      println("âŒ é”™è¯¯: æŒ‡å®šè·¯å¾„ä¸æ˜¯æ–‡ä»¶")
      return
    }
  } catch {
    @fs.IOError(msg) => {
      println("âŒ é”™è¯¯: æ— æ³•è®¿é—®æ–‡ä»¶ - " + msg)
      return
    }
  }
  
  try {
    // è¯»å–æ–‡ä»¶
    let gif_data = @fs.read_file_to_bytes(gif_path)
    println("âœ… æ–‡ä»¶è¯»å–æˆåŠŸ")
    println("   æ–‡ä»¶å¤§å°: " + gif_data.length().to_string() + " å­—èŠ‚")
    
    // åŸºæœ¬æ ¼å¼æ£€æŸ¥
    if gif_data.length() < 6 {
      println("âŒ é”™è¯¯: æ–‡ä»¶å¤ªå°ï¼Œä¸æ˜¯æœ‰æ•ˆçš„GIFæ–‡ä»¶")
      return
    }
    
    let signature = format_bytes_as_string(gif_data, 0, 6)
    if !signature.has_prefix("GIF") {
      println("âŒ é”™è¯¯: æ–‡ä»¶ç­¾åæ— æ•ˆï¼Œä¸æ˜¯GIFæ–‡ä»¶")
      println("   æ–‡ä»¶ç­¾å: " + signature)
      return
    }
    
    println("âœ… GIFæ–‡ä»¶æ ¼å¼éªŒè¯é€šè¿‡")
    println("")
    
    // è¯¦ç»†è§£æ
    parse_gif_details(gif_data)
    
  } catch {
    @fs.IOError(msg) => println("âŒ æ–‡ä»¶è¯»å–å¤±è´¥: " + msg)
  }
}

///| è¯¦ç»†è§£æGIFæ–‡ä»¶
fn parse_gif_details(gif_data: Bytes) -> Unit {
  // åŸºæœ¬ä¿¡æ¯è§£æ
  println("ğŸ“‹ åŸºæœ¬ä¿¡æ¯")
  println("--------------------------------------------------")
  
  match @penguins/gif_decoder/src/lib.parse_gif_info(gif_data) {
    Ok(info) => {
      println("ğŸ·ï¸  æ–‡ä»¶ç‰ˆæœ¬: GIF " + info.version)
      println("ğŸ“ å›¾åƒå°ºå¯¸: " + info.width.to_string() + " Ã— " + info.height.to_string() + " åƒç´ ")
      
      let megapixels = (info.width * info.height).to_double() / 1000000.0
      if megapixels >= 1.0 {
        println("   (çº¦ " + megapixels.to_string() + " ç™¾ä¸‡åƒç´ )")
      }
      
      println("ğŸ¨ é¢œè‰²ä¿¡æ¯:")
      if info.has_global_color_table {
        println("   - å…¨å±€é¢œè‰²è¡¨: æ˜¯")
        println("   - é¢œè‰²æ•°é‡: " + info.global_color_table_size.to_string() + " è‰²")
        println("   - é¢œè‰²åˆ†è¾¨ç‡: " + info.color_resolution.to_string() + " ä½")
        
        let color_depth = match info.global_color_table_size {
          2 => "å•è‰²"
          4 => "4è‰²"
          8 => "8è‰²"
          16 => "16è‰²"
          32 => "32è‰²"
          64 => "64è‰²"
          128 => "128è‰²"
          256 => "256è‰²"
          _ => info.global_color_table_size.to_string() + "è‰²"
        }
        println("   - è‰²å½©æ¨¡å¼: " + color_depth)
      } else {
        println("   - å…¨å±€é¢œè‰²è¡¨: å¦")
      }
      
      println("ğŸ”§ å…¶ä»–å±æ€§:")
      println("   - æ’åºæ ‡å¿—: " + (if info.sort_flag { "æ˜¯" } else { "å¦" }))
      println("   - èƒŒæ™¯é¢œè‰²ç´¢å¼•: " + info.bg_color_index.to_string())
      if info.pixel_aspect_ratio != 0 {
        println("   - åƒç´ å®½é«˜æ¯”: " + info.pixel_aspect_ratio.to_string())
      }
      
      println("")
      
      // é«˜çº§åˆ†æ
      println("ğŸ”¬ é«˜çº§åˆ†æ")
      println("--------------------------------------------------")
      
      analyze_file_structure(gif_data, info)
      
    }
    Err(msg) => {
      println("âŒ è§£æå¤±è´¥: " + msg)
    }
  }
}

///| åˆ†ææ–‡ä»¶ç»“æ„
fn analyze_file_structure(gif_data: Bytes, info: @penguins/gif_decoder/src/lib.GifInfo) -> Unit {
  // è®¡ç®—å„éƒ¨åˆ†å¤§å°
  let header_size = 6  // GIF header
  let lsd_size = 7     // Logical Screen Descriptor
  let global_color_table_size = if info.has_global_color_table {
    info.global_color_table_size * 3
  } else {
    0
  }
  
  let data_section_start = header_size + lsd_size + global_color_table_size
  let data_section_size = gif_data.length() - data_section_start
  
  println("ğŸ“Š æ–‡ä»¶ç»“æ„åˆ†æ:")
  println("   - æ–‡ä»¶å¤´: " + header_size.to_string() + " å­—èŠ‚")
  println("   - é€»è¾‘å±å¹•æè¿°ç¬¦: " + lsd_size.to_string() + " å­—èŠ‚")
  if global_color_table_size > 0 {
    println("   - å…¨å±€é¢œè‰²è¡¨: " + global_color_table_size.to_string() + " å­—èŠ‚")
  }
  println("   - æ•°æ®æ®µ: " + data_section_size.to_string() + " å­—èŠ‚")
  
  // å°è¯•å®Œæ•´è§£ç 
  match @penguins/gif_decoder/src/lib.decode_gif_complete(gif_data) {
    Ok(result) => {
      println("âœ… å®Œæ•´è§£ç æˆåŠŸ")
      println("   " + result)
    }
    Err(msg) => {
      println("âš ï¸  å®Œæ•´è§£ç éƒ¨åˆ†å¤±è´¥: " + msg)
      println("   (åŸºæœ¬ä¿¡æ¯è§£ææ­£å¸¸)")
    }
  }
  
  // æ–‡ä»¶å®Œæ•´æ€§æ£€æŸ¥
  println("")
  println("ğŸ” æ–‡ä»¶å®Œæ•´æ€§:")
  check_file_integrity(gif_data)
}

///| æ£€æŸ¥æ–‡ä»¶å®Œæ•´æ€§
fn check_file_integrity(gif_data: Bytes) -> Unit {
  let file_size = gif_data.length()
  
  // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦ä»¥trailerç»“å°¾
  if file_size > 0 && gif_data[file_size - 1].to_int() == 0x3B {
    println("   âœ… æ–‡ä»¶ç»“å°¾æ­£ç¡® (0x3B trailer)")
  } else {
    println("   âš ï¸  æ–‡ä»¶å¯èƒ½ä¸å®Œæ•´ (ç¼ºå°‘trailer)")
  }
  
  // æ£€æŸ¥æœ€å°æ–‡ä»¶å¤§å°
  if file_size >= 14 {  // æœ€å°GIFæ–‡ä»¶å¤§å°
    println("   âœ… æ–‡ä»¶å¤§å°ç¬¦åˆGIFæ ¼å¼è¦æ±‚")
  } else {
    println("   âŒ æ–‡ä»¶å¤§å°è¿‡å°")
  }
  
  // ç»™å‡ºæ–‡ä»¶ç±»å‹å»ºè®®
  println("")
  println("ğŸ’¡ å»ºè®®:")
  match file_size {
    s if s < 1024 => println("   - è¿™æ˜¯ä¸€ä¸ªéå¸¸å°çš„GIFæ–‡ä»¶ï¼Œå¯èƒ½æ˜¯ç®€å•å›¾æ ‡")
    s if s < 10240 => println("   - è¿™æ˜¯ä¸€ä¸ªå°å‹GIFæ–‡ä»¶ï¼Œé€‚åˆä½œä¸ºå›¾æ ‡æˆ–ç®€å•åŠ¨ç”»")
    s if s < 102400 => println("   - è¿™æ˜¯ä¸€ä¸ªä¸­ç­‰å¤§å°çš„GIFæ–‡ä»¶")
    s if s < 1048576 => println("   - è¿™æ˜¯ä¸€ä¸ªè¾ƒå¤§çš„GIFæ–‡ä»¶ï¼Œå¯èƒ½åŒ…å«å¤æ‚åŠ¨ç”»")
    _ => println("   - è¿™æ˜¯ä¸€ä¸ªå¾ˆå¤§çš„GIFæ–‡ä»¶ï¼ŒåŠ è½½å¯èƒ½éœ€è¦æ—¶é—´")
  }
}

///| è¿è¡Œå®Œæ•´æ¼”ç¤ºç¨‹åº
fn run_full_demo() -> Unit {
  // æ£€æŸ¥æ˜¯å¦æœ‰é»˜è®¤çš„æ¼”ç¤ºæ–‡ä»¶
  let demo_file = "gif/__Attack.gif"
  if @fs.path_exists(demo_file) {
    println("ğŸ¯ å‘ç°æ¼”ç¤ºæ–‡ä»¶ï¼Œå°†è¿›è¡Œåˆ†æ...")
    analyze_gif_file(demo_file)
    println("")
  }
  
  println("ğŸª è¿è¡Œå®Œæ•´åŠŸèƒ½æ¼”ç¤º")
  println("==================================================")
  
  // åŸæœ‰çš„æ¼”ç¤ºä»£ç 
  demo_gif_parsing()
  test_basic_functions()
  demo_error_handling()
  advanced_verification()
  
  println("")
  println("âœ… æ¼”ç¤ºå®Œæˆï¼")
  println("")
  println("ğŸ’¡ æç¤º: ä¸‹æ¬¡å¯ä»¥ç›´æ¥æŒ‡å®šæ–‡ä»¶è·¯å¾„æ¥åˆ†æç‰¹å®šçš„GIFæ–‡ä»¶")
  println("   ä¾‹å¦‚: moon run src/main your_image.gif")
}





///| é«˜çº§éªŒè¯æµ‹è¯•
fn advanced_verification() -> Unit {
  println("\nğŸš€ 4. é«˜çº§éªŒè¯æµ‹è¯•")
  println("------------------------------")
  
  // æµ‹è¯•æœ€å°æœ‰æ•ˆGIF
  println("ğŸ”¬ æœ€å°GIFæ–‡ä»¶æµ‹è¯•:")
  let minimal_gif = create_minimal_gif()
  match @penguins/gif_decoder/src/lib.decode_gif_complete(minimal_gif) {
    Ok(result) => println("   âœ… æˆåŠŸ: " + result)
    Err(msg) => println("   âŒ å¤±è´¥: " + msg)
  }
  
  // æµ‹è¯•è¾ƒå¤§çš„GIF
  println("\nğŸ”¬ è¾ƒå¤§GIFæ–‡ä»¶æµ‹è¯•:")
  let large_gif = create_large_test_gif()
  match @penguins/gif_decoder/src/lib.parse_gif_info(large_gif) {
    Ok(info) => {
      println("   âœ… è§£ææˆåŠŸ:")
      println("      - å°ºå¯¸: " + info.width.to_string() + "x" + info.height.to_string())
      println("      - é¢œè‰²æ•°: " + info.global_color_table_size.to_string())
    }
    Err(msg) => println("   âŒ è§£æå¤±è´¥: " + msg)
  }
  
  // å­—èŠ‚åºæµ‹è¯•
  println("\nğŸ”¬ å­—èŠ‚åºè½¬æ¢æµ‹è¯•:")
  test_byte_order()
}

///| æ¼”ç¤ºGIFè§£æåŠŸèƒ½
fn demo_gif_parsing() -> Unit {
  println("\nğŸ“‹ 1. GIFæ–‡ä»¶è§£ææ¼”ç¤º")
  println("------------------------------")
  
  // åˆ›å»ºä¸€ä¸ªå®Œæ•´çš„æ¨¡æ‹ŸGIFæ–‡ä»¶æ•°æ®
  let gif_data = create_sample_gif()
  
  // åŸºç¡€è§£ç 
  println("ğŸ” åŸºç¡€è§£ç :")
  match @penguins/gif_decoder/src/lib.decode_gif_basic(gif_data) {
    Ok(result) => println("   " + result)
    Err(msg) => println("   é”™è¯¯: " + msg)
  }
  
  // è¯¦ç»†ä¿¡æ¯è§£æ
  println("\nğŸ“Š è¯¦ç»†ä¿¡æ¯è§£æ:")
  match @penguins/gif_decoder/src/lib.parse_gif_info(gif_data) {
    Ok(info) => {
      println("   ç‰ˆæœ¬: " + info.version)
      println("   å°ºå¯¸: " + info.width.to_string() + "x" + info.height.to_string())
      println("   å…¨å±€é¢œè‰²è¡¨: " + (if info.has_global_color_table { "æ˜¯" } else { "å¦" }))
      if info.has_global_color_table {
        println("   é¢œè‰²æ•°é‡: " + info.global_color_table_size.to_string())
        println("   é¢œè‰²åˆ†è¾¨ç‡: " + info.color_resolution.to_string() + " ä½")
      }
      println("   æ’åºæ ‡å¿—: " + (if info.sort_flag { "æ˜¯" } else { "å¦" }))
      println("   èƒŒæ™¯é¢œè‰²ç´¢å¼•: " + info.bg_color_index.to_string())
      println("   åƒç´ å®½é«˜æ¯”: " + info.pixel_aspect_ratio.to_string())
    }
    Err(msg) => println("   é”™è¯¯: " + msg)
  }
  
  // å®Œæ•´è§£ç ï¼ˆåŒ…æ‹¬å›¾åƒä¿¡æ¯ï¼‰
  println("\nğŸ–¼ï¸ å®Œæ•´è§£ç :")
  let complete_gif = create_complete_gif()
  match @penguins/gif_decoder/src/lib.decode_gif_complete(complete_gif) {
    Ok(result) => println("   " + result)
    Err(msg) => println("   é”™è¯¯: " + msg)
  }
}

///| æµ‹è¯•åŸºç¡€åŠŸèƒ½
fn test_basic_functions() -> Unit {
  println("\nğŸ§ª 2. åŸºç¡€åŠŸèƒ½æµ‹è¯•")
  println("------------------------------")
  
  // æµ‹è¯•ä½è¯»å–å™¨
  println("ğŸ”§ ä½è¯»å–å™¨æµ‹è¯•:")
  let test_bytes = [0xAA, 0xBB, 0xCC]  // 10101010 11011011 11001100
  let data_list = @list.List::from_array(test_bytes.map(fn(x) { x.to_byte() }))
  let bit_reader = @penguins/gif_decoder/src/lib.new(data_list)
  
  let (reader1, bits1) = bit_reader.read_bits(4)
  match bits1 {
    Some(value) => println("   è¯»å–4ä½: " + value.to_string() + " (äºŒè¿›åˆ¶: " + format_binary(value, 4) + ")")
    None => println("   è¯»å–å¤±è´¥")
  }
  
  let (_, bits2) = reader1.read_bits(8)
  match bits2 {
    Some(value) => println("   è¯»å–8ä½: " + value.to_string() + " (äºŒè¿›åˆ¶: " + format_binary(value, 8) + ")")
    None => println("   è¯»å–å¤±è´¥")
  }
  
  // æµ‹è¯•å­—èŠ‚å·¥å…·
  println("\nğŸ”§ å­—èŠ‚å·¥å…·æµ‹è¯•:")
  let b1 = (0x34).to_byte()
  let b2 = (0x12).to_byte()
  let u16_value = @penguins/gif_decoder/src/lib.to_u16_le(b1, b2)
  println("   å°ç«¯åºè½¬æ¢: 0x" + b1.to_int().to_string() + " 0x" + b2.to_int().to_string() + " -> " + u16_value.to_string())
  
  // å†…ç½®æµ‹è¯•å‡½æ•°
  println("\nğŸ§ª å†…ç½®æµ‹è¯•:")
  let test_result = @penguins/gif_decoder/src/lib.test_gif_decoder()
  println("   " + test_result)
}

///| æ¼”ç¤ºé”™è¯¯å¤„ç†
fn demo_error_handling() -> Unit {
  println("\nâŒ 3. é”™è¯¯å¤„ç†æ¼”ç¤º")
  println("------------------------------")
  
  // æµ‹è¯•æ— æ•ˆæ–‡ä»¶
  println("ğŸš« æ— æ•ˆæ–‡ä»¶æµ‹è¯•:")
  let invalid_data = Bytes::from_array([1, 2, 3, 4, 5])
  match @penguins/gif_decoder/src/lib.decode_gif_basic(invalid_data) {
    Ok(result) => println("   æ„å¤–æˆåŠŸ: " + result)
    Err(msg) => println("   âœ“ æ­£ç¡®æ£€æµ‹åˆ°é”™è¯¯: " + msg)
  }
  
  // æµ‹è¯•æ–‡ä»¶å¤ªå°
  println("\nğŸš« æ–‡ä»¶å¤ªå°æµ‹è¯•:")
  let tiny_data = Bytes::from_array([71, 73, 70])  // åªæœ‰ "GIF"
  match @penguins/gif_decoder/src/lib.parse_gif_info(tiny_data) {
    Ok(_) => println("   æ„å¤–æˆåŠŸ")
    Err(msg) => println("   âœ“ æ­£ç¡®æ£€æµ‹åˆ°é”™è¯¯: " + msg)
  }
  
  // æµ‹è¯•é”™è¯¯ç‰ˆæœ¬
  println("\nğŸš« é”™è¯¯ç‰ˆæœ¬æµ‹è¯•:")
  let wrong_version = Bytes::from_array([
    71, 73, 70, 57, 57, 97,  // "GIF99a" - æ— æ•ˆç‰ˆæœ¬
    10, 0, 10, 0, 0, 0, 0
  ])
  match @penguins/gif_decoder/src/lib.decode_gif_basic(wrong_version) {
    Ok(_) => println("   æ„å¤–æˆåŠŸ")
    Err(msg) => println("   âœ“ æ­£ç¡®æ£€æµ‹åˆ°é”™è¯¯: " + msg)
  }
}

///| åˆ›å»ºç¤ºä¾‹GIFæ•°æ®
fn create_sample_gif() -> Bytes {
  Bytes::from_array([
    // GIFæ–‡ä»¶å¤´
    71, 73, 70, 56, 57, 97,   // "GIF89a"
    
    // é€»è¾‘å±å¹•æè¿°ç¬¦
    64, 0,                    // å®½åº¦ = 64
    48, 0,                    // é«˜åº¦ = 48
    0xF0,                     // packed: å…¨å±€é¢œè‰²è¡¨=1, åˆ†è¾¨ç‡=7, æ’åº=0, å¤§å°=0 (2è‰²)
    0,                        // èƒŒæ™¯é¢œè‰²ç´¢å¼• = 0
    0                         // åƒç´ å®½é«˜æ¯” = 0
  ])
}

///| åˆ›å»ºåŒ…å«å›¾åƒçš„å®Œæ•´GIFæ•°æ®
fn create_complete_gif() -> Bytes {
  Bytes::from_array([
    // GIFæ–‡ä»¶å¤´
    71, 73, 70, 56, 57, 97,   // "GIF89a"
    
    // é€»è¾‘å±å¹•æè¿°ç¬¦  
    32, 0,                    // å®½åº¦ = 32
    32, 0,                    // é«˜åº¦ = 32
    0x80,                     // packed: å…¨å±€é¢œè‰²è¡¨=1, åˆ†è¾¨ç‡=0, æ’åº=0, å¤§å°=0 (2è‰²)
    0,                        // èƒŒæ™¯é¢œè‰²ç´¢å¼•
    0,                        // åƒç´ å®½é«˜æ¯”
    
    // å…¨å±€é¢œè‰²è¡¨ (2è‰²)
    0, 0, 0,                  // é»‘è‰²
    255, 255, 255,            // ç™½è‰²
    
    // å›¾åƒæè¿°ç¬¦
    0x2C,                     // å›¾åƒåˆ†éš”ç¬¦
    0, 0,                     // left = 0
    0, 0,                     // top = 0  
    16, 0,                    // width = 16
    16, 0,                    // height = 16
    0x00,                     // packed: æ— å±€éƒ¨é¢œè‰²è¡¨, éäº¤é”™
    
    // LZWæœ€å°ä»£ç å¤§å°
    2,
    
    // å›¾åƒæ•°æ® (ç®€åŒ–çš„æ•°æ®å—)
    4,                        // æ•°æ®å—å¤§å° = 4
    0x04, 0x10, 0x18, 0x28,   // ç®€å•çš„LZWå‹ç¼©æ•°æ®
    0,                        // æ•°æ®å—ç»ˆæ­¢ç¬¦
    
    // GIFæ–‡ä»¶ç»ˆæ­¢ç¬¦
    0x3B
  ])
}

///| æ ¼å¼åŒ–äºŒè¿›åˆ¶è¡¨ç¤º
fn format_binary(value: Int, width: Int) -> String {
  let mut result = ""
  let mut temp = value
  
  for i = 0; i < width; i = i + 1 {
    let bit = if (temp.land(1)) != 0 { "1" } else { "0" }
    result = bit + result
    temp = temp >> 1
  }
  
  result
}

///| å°†å­—èŠ‚è½¬æ¢ä¸ºå¯è¯»å­—ç¬¦ä¸²
fn format_bytes_as_string(data: Bytes, start: Int, len: Int) -> String {
  let mut result = ""
  for i = 0; i < len; i = i + 1 {
    if start + i < data.length() {
      let byte_val = data[start + i].to_int()
      if byte_val >= 32 && byte_val <= 126 {  // å¯æ‰“å°ASCIIå­—ç¬¦
        result = result + String::from_array([Int::unsafe_to_char(byte_val)])
      } else {
        result = result + "\\x" + byte_val.to_string()
      }
    }
  }
  result
}

///| åˆ›å»ºæœ€å°çš„æœ‰æ•ˆGIFæ–‡ä»¶
fn create_minimal_gif() -> Bytes {
  Bytes::from_array([
    // GIF Header
    0x47, 0x49, 0x46, 0x38, 0x39, 0x61,  // "GIF89a"
    
    // Logical Screen Descriptor
    0x01, 0x00,  // Width = 1
    0x01, 0x00,  // Height = 1  
    0x80,        // Global Color Table Flag = 1
    0x00,        // Background Color Index = 0
    0x00,        // Pixel Aspect Ratio = 0
    
    // Global Color Table (2 colors)
    0x00, 0x00, 0x00,  // Color 0: Black
    0xFF, 0xFF, 0xFF,  // Color 1: White
    
    // Image Descriptor
    0x2C,        // Image Separator
    0x00, 0x00,  // Left = 0
    0x00, 0x00,  // Top = 0
    0x01, 0x00,  // Width = 1
    0x01, 0x00,  // Height = 1
    0x00,        // Packed = 0
    
    // Image Data
    0x02,        // LZW Minimum Code Size = 2
    0x02,        // Data Sub-block size = 2
    0x04, 0x01,  // LZW Data
    0x00,        // Data Sub-block Terminator
    
    // GIF Trailer
    0x3B
  ])
}

///| åˆ›å»ºè¾ƒå¤§çš„æµ‹è¯•GIF
fn create_large_test_gif() -> Bytes {
  Bytes::from_array([
    // GIF Header
    0x47, 0x49, 0x46, 0x38, 0x39, 0x61,  // "GIF89a"
    
    // Logical Screen Descriptor  
    0x10, 0x00,  // Width = 16
    0x10, 0x00,  // Height = 16
    0x91,        // Global Color Table, 4 colors
    0x00,        // Background = 0
    0x00,        // Pixel Aspect Ratio = 0
    
    // Global Color Table (4 colors)
    0x00, 0x00, 0x00,  // Black
    0xFF, 0x00, 0x00,  // Red  
    0x00, 0xFF, 0x00,  // Green
    0x00, 0x00, 0xFF,  // Blue
    
    // Image Descriptor
    0x2C,        // Image Separator
    0x00, 0x00,  // Left = 0
    0x00, 0x00,  // Top = 0
    0x08, 0x00,  // Width = 8
    0x08, 0x00,  // Height = 8
    0x00,        // No local color table
    
    // Image Data
    0x02,        // LZW min code size = 2
    0x08,        // Data block size = 8
    0x04, 0x10, 0x18, 0x28, 0x30, 0x38, 0x40, 0x05,  // LZW data
    0x00,        // Data block terminator
    0x3B         // GIF Trailer
  ])
}

///| æµ‹è¯•å­—èŠ‚åºè½¬æ¢
fn test_byte_order() -> Unit {
  println("   æµ‹è¯•å°ç«¯åºè½¬æ¢:")
  
  // æµ‹è¯•å‡ ä¸ªå€¼
  let test_cases = [
    (0x00, 0x01, 256),    // 0x0100 = 256
    (0xFF, 0x00, 255),    // 0x00FF = 255  
    (0x34, 0x12, 4660),   // 0x1234 = 4660
    (0xCD, 0xAB, 43981)   // 0xABCD = 43981
  ]
  
  for i = 0; i < test_cases.length(); i = i + 1 {
    let (b1, b2, expected) = test_cases[i]
    let result = @penguins/gif_decoder/src/lib.to_u16_le(b1.to_byte(), b2.to_byte())
    let status = if result == expected { "âœ…" } else { "âŒ" }
    println("      " + status + " 0x" + b1.to_string() + " 0x" + b2.to_string() + " -> " + result.to_string() + " (æœŸæœ›: " + expected.to_string() + ")")
  }
}