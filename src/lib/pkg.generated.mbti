// Generated using `moon info`, DON'T EDIT IT
package "Penguinsltp/gif_decoder/src/lib"

import(
  "moonbitlang/core/list"
)

// Values
fn analyze_gif_structure(Bytes) -> Result[String, String]

let application_extension_label : Byte

fn apply_color_table(@list.List[Byte], @list.List[ColorTableEntry], Int?) -> @list.List[RgbaColor]

fn apply_color_table_with_options(@list.List[Byte], @list.List[ColorTableEntry], Int?, TransparencyOptions) -> @list.List[RgbaColor]

fn apply_disposal_method_to_canvas(Canvas, Canvas?, DisposalMethod, Int, Int, Int, Int) -> Canvas

fn apply_graphic_control(Canvas, GraphicControlExtension, @list.List[Byte], @list.List[ColorTableEntry], ImageDescriptor) -> Result[Canvas, GifError]

fn array_bytes_to_list(Array[Byte]) -> @list.List[Byte]

fn bytes_to_string(Bytes, Int, Int) -> String

fn calculate_color_table_size(Int) -> Int

fn color_entry_to_rgba(ColorTableEntry, Int) -> RgbaColor

let comment_label : Byte

fn create_color_entry(Int, Int, Int) -> ColorTableEntry

fn create_color_table_entry(Int, Int, Int) -> ColorTableEntry

fn create_default_image_descriptor(Int, Int) -> ImageDescriptor

fn create_default_logical_screen(Int, Int) -> LogicalScreenDescriptor

fn create_disposal_method(Int) -> DisposalMethod

fn create_frame(ImageData, @list.List[ColorTableEntry]?, GraphicControlExtension?, Int, Int) -> Result[ImageFrame, GifError]

fn create_frame_from_rgba(Int, Int, Int, Int, Array[RgbaColor], Int, Int) -> Result[GifFrameInput, GifError]

fn create_frame_with_options(ImageData, @list.List[ColorTableEntry]?, GraphicControlExtension?, Int, Int, TransparencyOptions) -> Result[ImageFrame, GifError]

fn create_gif_data_blocks() -> @list.List[GifDataBlock]

fn create_gif_encoder_options(Int, Int, @list.List[ColorTableEntry]?, Int, Int, Int) -> GifEncoderOptions

fn create_gif_header(String) -> GifHeader

fn create_image_data(ImageDesc, @list.List[Byte]) -> ImageData

fn create_parse_options(Bool, Bool, Int?) -> GifParseOptions

fn create_rgba_color(Int, Int, Int, Int) -> RgbaColor

fn create_test_gif_data() -> Bytes

fn create_transparency_options(TransparencyStrategy, Int, Bool, RgbaColor) -> TransparencyOptions

fn decode_gif_basic(Bytes) -> Result[String, String]

fn decode_gif_complete(Bytes) -> Result[String, String]

fn decode_lzw(@list.List[Byte], Int) -> Result[@list.List[Byte], GifError]

fn decode_lzw_from_array(Array[Int], Int) -> Result[Array[Int], GifError]

fn default_optimization_options() -> GifOptimizationOptions

fn default_parse_options() -> GifParseOptions

fn default_streaming_options() -> StreamingDecoderOptions

fn default_transparency_options() -> TransparencyOptions

let disposal_keep : Int

let disposal_none : Int

let disposal_restore_background : Int

let disposal_restore_previous : Int

let extension_introducer : Byte

fn extract_animation_info(Gif) -> AnimationInfo

fn fast_clear_region(Canvas, Int, Int, Int, Int, RgbaColor) -> Unit

fn find_image_descriptor(Bytes, Int) -> Result[Int, String]

fn get_color_table_size_from_descriptor(LogicalScreenDescriptor) -> Int

fn get_effective_color_table(ImageData, @list.List[ColorTableEntry]?) -> @list.List[ColorTableEntry]?

fn get_local_color_table_size(ImageDescriptor) -> Int

let gif_signature : String

let gif_version_87a : String

let gif_version_89a : String

let graphic_control_label : Byte

fn has_global_color_table(LogicalScreenDescriptor) -> Bool

fn has_local_color_table(ImageDescriptor) -> Bool

let image_separator : Byte

fn is_valid_disposal_method(Int) -> Bool

let lzw_clear_code : Int

let lzw_end_code : Int

let lzw_first_code : Int

let lzw_max_code_size : Int

fn merge_color_tables(@list.List[ColorTableEntry]?, @list.List[ColorTableEntry]?, Int) -> @list.List[ColorTableEntry]

fn new(@list.List[Byte]) -> BitReader

fn normalize_pixel_data(@list.List[Byte], Int, Bool) -> Result[@list.List[Byte], GifError]

fn optimize_gif(Gif, GifOptimizationOptions) -> (Gif, OptimizationReport)

fn pack_image_packed_field(Bool, Bool, Bool, Int) -> Int

fn pack_logical_screen_packed_field(Bool, Int, Bool, Int) -> Int

fn parse_application_extension_block(Bytes, Int, Bool) -> Result[(ApplicationExtension, Int), GifError]

fn parse_color_table_from_bytes(Bytes, Int, Int) -> Result[(@list.List[ColorTableEntry], Int), GifError]

fn parse_extension_info(Bytes, Int) -> Result[(String, Int), String]

fn parse_gif(Bytes) -> Result[Gif, GifError]

fn parse_gif_header(Bytes) -> Result[GifHeader, GifError]

fn parse_gif_info(Bytes) -> Result[GifInfo, String]

fn parse_gif_with_options(Bytes, GifParseOptions) -> Result[Gif, GifError]

fn parse_global_color_table(Bytes, Int, Int) -> Result[Array[ColorEntry], String]

fn parse_graphic_control_block(Bytes, Int) -> Result[(GraphicControlExtension, Int), GifError]

fn parse_image_descriptor(Bytes, Int) -> Result[(ImageDesc, Int), String]

fn parse_image_descriptor_block(Bytes, Int) -> Result[(ImageDescriptor, Int), GifError]

fn parse_logical_screen_descriptor_block(Bytes) -> Result[(LogicalScreenDescriptor, Int), GifError]

fn parse_plain_text_block(Bytes, Int, Bool) -> Result[(PlainTextExtension, Int), GifError]

let plain_text_label : Byte

fn rebuild_gif(Gif, @list.List[GifDataBlock]) -> Gif

fn render_all_frames(Gif) -> Result[@list.List[ImageFrame], GifError]

fn render_all_frames_with_options(Gif, TransparencyOptions) -> Result[@list.List[ImageFrame], GifError]

fn render_frame_to_canvas(Canvas, ImageData, @list.List[ColorTableEntry], Int?) -> Result[Unit, GifError]

fn render_frame_to_canvas_with_options(Canvas, ImageData, @list.List[ColorTableEntry], Int?, TransparencyOptions) -> Result[Unit, GifError]

fn render_pixels_to_canvas(Canvas, @list.List[RgbaColor], ImageDescriptor) -> Result[Canvas, GifError]

fn test_all_type_constructions() -> Result[String, GifError]

fn to_int8(Byte) -> Int

fn to_u16_le(Byte, Byte) -> Int

let trailer : Byte

fn transparency_strategy_alpha_threshold() -> TransparencyStrategy

fn transparency_strategy_binary() -> TransparencyStrategy

fn transparency_strategy_preserve_alpha() -> TransparencyStrategy

fn unpack_image_packed_field(Int) -> (Bool, Bool, Bool, Int)

fn unpack_logical_screen_packed_field(Int) -> (Bool, Int, Bool, Int)

fn validate_dimensions(Int, Int) -> Result[Unit, GifError]

fn validate_gif_header(GifHeader) -> Result[Unit, GifError]

fn validate_graphic_control(GraphicControlExtension) -> Result[Unit, GifError]

fn validate_image_descriptor(ImageDescriptor) -> Result[Unit, GifError]

fn validate_logical_screen(LogicalScreenDescriptor) -> Result[Unit, GifError]

fn wasm_decode_gif_summary(Bytes) -> Result[String, String]

fn wasm_encode_single_frame(Array[RgbaColor], Int, Int) -> Result[Bytes, String]

fn wasm_optimize_gif(Bytes) -> Result[String, String]

fn wasm_stream_decode(Bytes, Int) -> Result[Int, String]

// Errors

// Types and methods
pub struct AnimationController {
  frames : @list.List[ImageFrame]
  image_descriptors : @list.List[ImageDescriptor]
  state : AnimationState
}
fn AnimationController::current_frame(Self) -> ImageFrame?
fn AnimationController::get_current_pixels(Self) -> Array[RgbaColor]?
fn AnimationController::is_finished(Self) -> Bool
fn AnimationController::new(@list.List[ImageFrame], @list.List[ImageDescriptor], Int, Int, Int) -> Self
fn AnimationController::reset(Self) -> Unit
fn AnimationController::update(Self, Int) -> Bool
impl Show for AnimationController

pub struct AnimationInfo {
  loop_count : Int
  background_color_index : Int
  pixel_aspect_ratio : Int
}
impl Show for AnimationInfo

pub struct AnimationState {
  mut current_frame : Int
  mut accumulated_time : Int
  total_frames : Int
  mut played_loops : Int
  loop_count : Int
  renderer : CanvasRenderer?
}
impl Show for AnimationState

pub struct ApplicationExtension {
  application_identifier : String
  application_auth_code : String
  application_data : @list.List[Byte]
}
impl Show for ApplicationExtension

pub struct BitReader {
  data : @list.List[Byte]
  current_byte : Byte
  bit_offset : Int
  bits_consumed : Int
  initialized : Bool
}
fn BitReader::read_bits(Self, Int) -> (Self, Int?)

pub struct Canvas {
  width : Int
  height : Int
  pixels : Array[RgbaColor]
  background_color : RgbaColor
  mut previous_frame : Array[RgbaColor]?
}
fn Canvas::apply_disposal_method(Self, Int, Int, Int, Int, Int) -> Unit
fn Canvas::clear_to_background(Self) -> Unit
fn Canvas::new(Int, Int, RgbaColor) -> Self
fn Canvas::save_previous_frame(Self) -> Unit
impl Show for Canvas

pub struct CanvasRenderer {
  canvas : Canvas
  mut previous_disposal : Int
  mut previous_bounds : (Int, Int, Int, Int)
}
fn CanvasRenderer::get_canvas_pixels(Self) -> Array[RgbaColor]
fn CanvasRenderer::new(Int, Int, RgbaColor) -> Self
fn CanvasRenderer::render_frame_with_disposal(Self, ImageFrame, ImageDescriptor) -> Result[Unit, GifError]
impl Show for CanvasRenderer

pub struct CodeReader {
  data : @list.List[Byte]
  mut bit_buffer : Int
  mut bit_count : Int
  mut byte_index : Int
}
fn CodeReader::new(@list.List[Byte]) -> Self
fn CodeReader::read_code(Self, Int) -> Int?

pub struct ColorEntry {
  red : Int
  green : Int
  blue : Int
}
impl Eq for ColorEntry
impl Show for ColorEntry

pub struct ColorTableEntry {
  red : Int
  green : Int
  blue : Int
}
impl Eq for ColorTableEntry
impl Show for ColorTableEntry

pub struct CommentExtension {
  comment_data : @list.List[Byte]
}
impl Show for CommentExtension

pub enum DetailedGifError {
  InvalidSignature(String)
  UnsupportedVersion(String)
  InvalidBlockSize(Int)
  InvalidLzwMinimumCodeSize(Int)
  InvalidColorTableSize(Int)
  ImageTooLarge(Int, Int)
  InvalidDisposalMethod(Int)
  CorruptedSubBlock
}
impl Show for DetailedGifError

pub enum DisposalMethod {
  None
  DoNotDispose
  RestoreToBackground
  RestoreToPrevious
}
impl Eq for DisposalMethod
impl Show for DisposalMethod

pub enum ExtensionType {
  PlainText(PlainTextExtension)
  GraphicControl(GraphicControlExtension)
  Comment(CommentExtension)
  Application(ApplicationExtension)
}
impl Show for ExtensionType

pub struct Gif {
  header : GifHeader
  logical_screen : LogicalScreenDescriptor
  global_color_table : @list.List[ColorTableEntry]?
  data_blocks : @list.List[GifDataBlock]
}
impl Show for Gif

pub enum GifDataBlock {
  Extension(ExtensionType)
  Image(ImageData)
  Trailer
}
impl Show for GifDataBlock

pub struct GifEncoder {
  options : GifEncoderOptions
  frames : Array[GifFrameInput]
}
fn GifEncoder::add_frame(Self, GifFrameInput) -> Result[Unit, GifError]
fn GifEncoder::build(Self) -> Result[Bytes, GifError]
fn GifEncoder::frame_count(Self) -> Int
fn GifEncoder::new(GifEncoderOptions) -> Self
impl Show for GifEncoder

pub struct GifEncoderOptions {
  width : Int
  height : Int
  global_color_table : @list.List[ColorTableEntry]?
  background_color_index : Int
  pixel_aspect_ratio : Int
  loop_count : Int
}
impl Show for GifEncoderOptions

pub enum GifError {
  InvalidHeader
  InvalidLogicalScreen
  InvalidColorTable
  InvalidImageDescriptor
  InvalidExtension
  InvalidFormat
  LzwDecodingError
  NoColorTable
  UnsupportedFeature
  DataCorrupted
  UnexpectedEndOfFile
  InvalidBlockSize(Int)
}
impl Show for GifError

pub struct GifFrameInput {
  descriptor : ImageDescriptor
  color_indexes : @list.List[Byte]
  local_color_table : @list.List[ColorTableEntry]?
  delay_time : Int
  disposal_method : Int
  transparent_index : Int?
}
impl Show for GifFrameInput

pub struct GifHeader {
  signature : String
  version : String
}
impl Show for GifHeader

pub struct GifInfo {
  version : String
  width : Int
  height : Int
  has_global_color_table : Bool
  global_color_table_size : Int
  color_resolution : Int
  sort_flag : Bool
  bg_color_index : Int
  pixel_aspect_ratio : Int
}
impl Show for GifInfo

pub struct GifOptimizationOptions {
  remove_duplicate_frames : Bool
  enforce_transparent_background : Bool
  prefer_global_palette : Bool
  shrink_local_palettes : Bool
}
impl Show for GifOptimizationOptions

pub struct GifParseOptions {
  decompress_image_data : Bool
  strict_mode : Bool
  max_pixels : Int?
}
impl Show for GifParseOptions

pub struct GraphicControlExtension {
  disposal_method : Int
  user_input_flag : Bool
  transparent_color_flag : Bool
  delay_time : Int
  transparent_color_index : Int
}
impl Show for GraphicControlExtension

pub struct ImageData {
  descriptor : ImageDescriptor
  local_color_table : @list.List[ColorTableEntry]?
  image_data : @list.List[Byte]
}
impl Show for ImageData

pub struct ImageDesc {
  left : Int
  top : Int
  width : Int
  height : Int
  has_local_color_table : Bool
  interlaced : Bool
  sorted : Bool
  local_color_table_size : Int
}
impl Show for ImageDesc

pub struct ImageDescriptor {
  left : Int
  top : Int
  width : Int
  height : Int
  local_color_table_flag : Bool
  interlace_flag : Bool
  sort_flag : Bool
  local_color_table_size : Int
}
impl Show for ImageDescriptor

pub struct ImageFrame {
  width : Int
  height : Int
  pixels : Array[RgbaColor]
  delay : Int
  disposal_method : Int
  transparent_index : Int?
}
impl Show for ImageFrame

pub struct LogicalScreenDescriptor {
  screen_width : Int
  screen_height : Int
  global_color_table_flag : Bool
  color_resolution : Int
  sort_flag : Bool
  global_color_table_size : Int
  background_color_index : Int
  pixel_aspect_ratio : Int
}
impl Show for LogicalScreenDescriptor

pub struct LzwDecoder {
  dictionary : Array[LzwEntry]
  mut code_size : Int
  mut clear_code : Int
  mut end_code : Int
  mut next_code : Int
  mut max_code : Int
  mut dictionary_size : Int
}
fn LzwDecoder::add_to_dictionary(Self, Int, Byte) -> Unit
fn LzwDecoder::get_first_char(Self, Int) -> Byte
fn LzwDecoder::get_string(Self, Int) -> @list.List[Byte]
fn LzwDecoder::new(Int) -> Self
fn LzwDecoder::reset_dictionary(Self, Int) -> Unit

pub struct LzwEntry {
  prefix : Int
  suffix : Byte
}

pub struct OptimizationReport {
  removed_frames : Int
  updated_transparency : Int
  normalized_palettes : Int
}
impl Show for OptimizationReport

pub struct PlainTextExtension {
  text_grid_left_position : Int
  text_grid_top_position : Int
  text_grid_width : Int
  text_grid_height : Int
  character_cell_width : Int
  character_cell_height : Int
  text_foreground_color_index : Int
  text_background_color_index : Int
  plain_text_data : @list.List[Byte]
}
impl Show for PlainTextExtension

pub struct RgbaColor {
  red : Int
  green : Int
  blue : Int
  alpha : Int
}
impl Eq for RgbaColor
impl Show for RgbaColor

pub struct StreamingDecoderOptions {
  decompress_image_data : Bool
  strict_mode : Bool
  compact_threshold : Int
}
impl Show for StreamingDecoderOptions

pub enum StreamingEvent {
  Header(GifHeader, LogicalScreenDescriptor)
  GlobalColorTable(@list.List[ColorTableEntry])
  GraphicControl(GraphicControlExtension)
  Comment(CommentExtension)
  PlainText(PlainTextExtension)
  Application(ApplicationExtension)
  Image(ImageData, GraphicControlExtension?)
  Trailer
}
impl Show for StreamingEvent

pub struct StreamingGifDecoder {
  options : StreamingDecoderOptions
  mut buffer : Array[Byte]
  mut consumed : Int
  mut finished : Bool
  mut header : GifHeader?
  mut logical_screen : LogicalScreenDescriptor?
  mut global_table_emitted : Bool
  mut pending_graphic_control : GraphicControlExtension?
}
fn StreamingGifDecoder::finish(Self) -> Result[Unit, GifError]
fn StreamingGifDecoder::is_finished(Self) -> Bool
fn StreamingGifDecoder::new(StreamingDecoderOptions) -> Self
fn StreamingGifDecoder::process_chunk(Self, Bytes) -> Result[@list.List[StreamingEvent], GifError]
impl Show for StreamingGifDecoder

pub struct TransparencyOptions {
  strategy : TransparencyStrategy
  alpha_threshold : Int
  preserve_background : Bool
  fallback_color : RgbaColor
}
impl Show for TransparencyOptions

pub enum TransparencyStrategy {
  Binary
  AlphaThreshold
  PreserveAlpha
}
impl Eq for TransparencyStrategy
impl Show for TransparencyStrategy

// Type aliases

// Traits

