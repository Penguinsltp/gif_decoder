///|
fn main {
  let args = @sys.get_cli_args()
  if args.length() < 2 {
    println("ğŸ¨ GIFè§£ç å™¨ - ä½¿ç”¨è¯´æ˜")
    println("==================================================")
    println("ç”¨æ³•: moon run src/main <gifæ–‡ä»¶è·¯å¾„>")
    println("ç¤ºä¾‹: moon run src/main gif/__Attack.gif")
    println("      moon run src/main /path/to/your/image.gif")
    println("")
    println(
      "ğŸ”§ å¦‚æœä¸æä¾›æ–‡ä»¶è·¯å¾„ï¼Œå°†è¿è¡Œå®Œæ•´çš„æ¼”ç¤ºç¨‹åº...",
    )
    println("")

    // è¿è¡Œå®Œæ•´æ¼”ç¤º
    run_full_demo()
  } else {
    let gif_path = args[1]
    println("ğŸ¨ GIFè§£ç å™¨ - æ–‡ä»¶åˆ†æ")
    println("==================================================")

    // è§£ææŒ‡å®šçš„GIFæ–‡ä»¶
    analyze_gif_file(gif_path)
  }
}

///|
/// åˆ†ææŒ‡å®šçš„GIFæ–‡ä»¶
fn analyze_gif_file(gif_path : String) -> Unit {
  println("ğŸ“‚ ç›®æ ‡æ–‡ä»¶: " + gif_path)
  println("--------------------------------------------------")

  // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
  if !@fs.path_exists(gif_path) {
    println("âŒ é”™è¯¯: æ–‡ä»¶ä¸å­˜åœ¨")
    println("   è¯·æ£€æŸ¥æ–‡ä»¶è·¯å¾„æ˜¯å¦æ­£ç¡®")
    return
  }

  // æ£€æŸ¥æ˜¯å¦ä¸ºæ–‡ä»¶
  try {
    if !@fs.is_file(gif_path) {
      println("âŒ é”™è¯¯: æŒ‡å®šè·¯å¾„ä¸æ˜¯æ–‡ä»¶")
      return
    }
  } catch {
    @fs.IOError(msg) => {
      println("âŒ é”™è¯¯: æ— æ³•è®¿é—®æ–‡ä»¶ - " + msg)
      return
    }
  }
  try {
    // è¯»å–æ–‡ä»¶
    let gif_data = @fs.read_file_to_bytes(gif_path)
    println("âœ… æ–‡ä»¶è¯»å–æˆåŠŸ")
    println("   æ–‡ä»¶å¤§å°: " + gif_data.length().to_string() + " å­—èŠ‚")

    // åŸºæœ¬æ ¼å¼æ£€æŸ¥
    if gif_data.length() < 6 {
      println("âŒ é”™è¯¯: æ–‡ä»¶å¤ªå°ï¼Œä¸æ˜¯æœ‰æ•ˆçš„GIFæ–‡ä»¶")
      return
    }
    let signature = @gif_decoder_lib.bytes_to_string(gif_data, 0, 6)
    if !signature.has_prefix("GIF") {
      println("âŒ é”™è¯¯: æ–‡ä»¶ç­¾åæ— æ•ˆï¼Œä¸æ˜¯GIFæ–‡ä»¶")
      println("   æ–‡ä»¶ç­¾å: " + signature)
      return
    }
    println("âœ… GIFæ–‡ä»¶æ ¼å¼éªŒè¯é€šè¿‡")
    println("")

    // è¯¦ç»†è§£æ
    parse_gif_details(gif_data)

    // æ·»åŠ é¢œè‰²è¡¨åˆ†æ
    analyze_color_table(gif_data)

    // æ·»åŠ å›¾åƒåˆ†æ
    analyze_image_data(gif_data)
  } catch {
    @fs.IOError(msg) => println("âŒ æ–‡ä»¶è¯»å–å¤±è´¥: " + msg)
  }
}

///|
/// è¯¦ç»†è§£æGIFæ–‡ä»¶
fn parse_gif_details(gif_data : Bytes) -> Unit {
  // åŸºæœ¬ä¿¡æ¯è§£æ
  println("ğŸ“‹ åŸºæœ¬ä¿¡æ¯")
  println("--------------------------------------------------")
  match @gif_decoder_lib.parse_gif_info(gif_data) {
    Ok(info) => {
      println("ğŸ·ï¸  æ–‡ä»¶ç‰ˆæœ¬: GIF " + info.version)
      println(
        "ğŸ“ å›¾åƒå°ºå¯¸: " +
        info.width.to_string() +
        " Ã— " +
        info.height.to_string() +
        " åƒç´ ",
      )
      let megapixels = (info.width * info.height).to_double() / 1000000.0
      if megapixels >= 1.0 {
        println("   (çº¦ " + megapixels.to_string() + " ç™¾ä¸‡åƒç´ )")
      }
      println("ğŸ¨ é¢œè‰²ä¿¡æ¯:")
      if info.has_global_color_table {
        println("   - å…¨å±€é¢œè‰²è¡¨: æ˜¯")
        println(
          "   - é¢œè‰²æ•°é‡: " +
          info.global_color_table_size.to_string() +
          " è‰²",
        )
        println(
          "   - é¢œè‰²åˆ†è¾¨ç‡: " + info.color_resolution.to_string() + " ä½",
        )
        let color_depth = match info.global_color_table_size {
          2 => "å•è‰²"
          4 => "4è‰²"
          8 => "8è‰²"
          16 => "16è‰²"
          32 => "32è‰²"
          64 => "64è‰²"
          128 => "128è‰²"
          256 => "256è‰²"
          _ => info.global_color_table_size.to_string() + "è‰²"
        }
        println("   - è‰²å½©æ¨¡å¼: " + color_depth)
      } else {
        println("   - å…¨å±€é¢œè‰²è¡¨: å¦")
      }
      println("ğŸ”§ å…¶ä»–å±æ€§:")
      println(
        "   - æ’åºæ ‡å¿—: " + (if info.sort_flag { "æ˜¯" } else { "å¦" }),
      )
      println("   - èƒŒæ™¯é¢œè‰²ç´¢å¼•: " + info.bg_color_index.to_string())
      if info.pixel_aspect_ratio != 0 {
        println("   - åƒç´ å®½é«˜æ¯”: " + info.pixel_aspect_ratio.to_string())
      }
      println("")

      // é«˜çº§åˆ†æ
      println("ğŸ”¬ é«˜çº§åˆ†æ")
      println("--------------------------------------------------")
      analyze_file_structure(gif_data, info)
    }
    Err(msg) => println("âŒ è§£æå¤±è´¥: " + msg)
  }
}

///|
/// åˆ†ææ–‡ä»¶ç»“æ„
fn analyze_file_structure(
  gif_data : Bytes,
  info : @gif_decoder_lib.GifInfo,
) -> Unit {
  // è®¡ç®—å„éƒ¨åˆ†å¤§å°
  let header_size = 6 // GIF header
  let lsd_size = 7 // Logical Screen Descriptor
  let global_color_table_size = if info.has_global_color_table {
    info.global_color_table_size * 3
  } else {
    0
  }
  let data_section_start = header_size + lsd_size + global_color_table_size
  let data_section_size = gif_data.length() - data_section_start
  println("ğŸ“Š æ–‡ä»¶ç»“æ„åˆ†æ:")
  println("   - æ–‡ä»¶å¤´: " + header_size.to_string() + " å­—èŠ‚")
  println("   - é€»è¾‘å±å¹•æè¿°ç¬¦: " + lsd_size.to_string() + " å­—èŠ‚")
  if global_color_table_size > 0 {
    println(
      "   - å…¨å±€é¢œè‰²è¡¨: " + global_color_table_size.to_string() + " å­—èŠ‚",
    )
  }
  println("   - æ•°æ®æ®µ: " + data_section_size.to_string() + " å­—èŠ‚")

  // å°è¯•å®Œæ•´è§£ç 
  match @gif_decoder_lib.decode_gif_complete(gif_data) {
    Ok(result) => {
      println("âœ… å®Œæ•´è§£ç æˆåŠŸ")
      println("   " + result)
    }
    Err(msg) => {
      println("âš ï¸  å®Œæ•´è§£ç éƒ¨åˆ†å¤±è´¥: " + msg)
      println("   (åŸºæœ¬ä¿¡æ¯è§£ææ­£å¸¸)")
    }
  }

  // æ–‡ä»¶å®Œæ•´æ€§æ£€æŸ¥
  println("")
  println("ğŸ” æ–‡ä»¶å®Œæ•´æ€§:")
  check_file_integrity(gif_data)
}

///|
/// åˆ†æé¢œè‰²è¡¨
fn analyze_color_table(gif_data : Bytes) -> Unit {
  match @gif_decoder_lib.parse_gif_info(gif_data) {
    Ok(info) =>
      if info.has_global_color_table {
        println("ğŸ¨ é¢œè‰²è¡¨è¯¦ç»†åˆ†æ")
        println("--------------------------------------------------")
        let color_table_offset = 13 // å¤´éƒ¨ + é€»è¾‘å±å¹•æè¿°ç¬¦
        match
          @gif_decoder_lib.parse_global_color_table(
            gif_data,
            color_table_offset,
            info.global_color_table_size,
          ) {
          Ok(colors) => {
            println("âœ… é¢œè‰²è¡¨è§£ææˆåŠŸ")
            println("   å…± " + colors.length().to_string() + " ç§é¢œè‰²:")

            // æ˜¾ç¤ºå‰å‡ ç§é¢œè‰²
            let display_count = if colors.length() > 8 {
              8
            } else {
              colors.length()
            }
            for i = 0; i < display_count; i = i + 1 {
              let color = colors[i]
              println(
                "   [" +
                i.to_string() +
                "] RGB(" +
                color.red.to_string() +
                ", " +
                color.green.to_string() +
                ", " +
                color.blue.to_string() +
                ") " +
                get_color_description(color),
              )
            }
            if colors.length() > display_count {
              println(
                "   ... (è¿˜æœ‰ " +
                (colors.length() - display_count).to_string() +
                " ç§é¢œè‰²)",
              )
            }

            // é¢œè‰²ç»Ÿè®¡
            analyze_color_statistics(colors)
          }
          Err(msg) => println("âŒ é¢œè‰²è¡¨è§£æå¤±è´¥: " + msg)
        }
        println("")
      }
    Err(_) => ()
  }
}

///|
/// åˆ†æå›¾åƒæ•°æ®
fn analyze_image_data(gif_data : Bytes) -> Unit {
  println("ğŸ–¼ï¸ å›¾åƒæ•°æ®åˆ†æ")
  println("--------------------------------------------------")
  match @gif_decoder_lib.parse_gif_info(gif_data) {
    Ok(info) => {
      let data_start = 13 +
        (if info.has_global_color_table {
          info.global_color_table_size * 3
        } else {
          0
        })
      match @gif_decoder_lib.find_image_descriptor(gif_data, data_start) {
        Ok(img_offset) =>
          match @gif_decoder_lib.parse_image_descriptor(gif_data, img_offset) {
            Ok((desc, next_offset)) => {
              println("âœ… å›¾åƒæè¿°ç¬¦è§£ææˆåŠŸ:")
              println(
                "   - ä½ç½®: (" +
                desc.left.to_string() +
                ", " +
                desc.top.to_string() +
                ")",
              )
              println(
                "   - å°ºå¯¸: " +
                desc.width.to_string() +
                "Ã—" +
                desc.height.to_string(),
              )
              println(
                "   - å±€éƒ¨é¢œè‰²è¡¨: " +
                (if desc.has_local_color_table { "æ˜¯" } else { "å¦" }),
              )
              println(
                "   - äº¤é”™æ¨¡å¼: " +
                (if desc.interlaced { "æ˜¯" } else { "å¦" }),
              )
              println(
                "   - æ’åºæ ‡å¿—: " +
                (if desc.sorted { "æ˜¯" } else { "å¦" }),
              )
              if desc.has_local_color_table {
                println(
                  "   - å±€éƒ¨é¢œè‰²æ•°: " +
                  desc.local_color_table_size.to_string(),
                )
              }

              // è®¡ç®—å‹ç¼©æ¯”
              let pixel_count = desc.width * desc.height
              let uncompressed_size = pixel_count // å‡è®¾æ¯åƒç´ 1å­—èŠ‚
              let remaining_data = gif_data.length() - next_offset
              if remaining_data > 0 {
                let compression_ratio = uncompressed_size.to_double() /
                  remaining_data.to_double()
                println(
                  "   - ä¼°è®¡å‹ç¼©æ¯”: " +
                  compression_ratio.to_string() +
                  ":1",
                )
              }
            }
            Err(msg) => println("âŒ å›¾åƒæè¿°ç¬¦è§£æå¤±è´¥: " + msg)
          }
        Err(msg) => println("âŒ æœªæ‰¾åˆ°å›¾åƒæè¿°ç¬¦: " + msg)
      }
    }
    Err(_) => ()
  }
  println("")
}

///|
/// è·å–é¢œè‰²æè¿°
fn get_color_description(color : @gif_decoder_lib.ColorEntry) -> String {
  match (color.red, color.green, color.blue) {
    (0, 0, 0) => "é»‘è‰²"
    (255, 255, 255) => "ç™½è‰²"
    (255, 0, 0) => "çº¢è‰²"
    (0, 255, 0) => "ç»¿è‰²"
    (0, 0, 255) => "è“è‰²"
    (255, 255, 0) => "é»„è‰²"
    (255, 0, 255) => "æ´‹çº¢"
    (0, 255, 255) => "é’è‰²"
    (r, g, b) if r == g && g == b => "ç°è‰²"
    _ => ""
  }
}

///|
/// åˆ†æé¢œè‰²ç»Ÿè®¡
fn analyze_color_statistics(
  colors : Array[@gif_decoder_lib.ColorEntry],
) -> Unit {
  let mut grayscale_count = 0
  let mut primary_count = 0
  for i = 0; i < colors.length(); i = i + 1 {
    let color = colors[i]

    // æ£€æŸ¥æ˜¯å¦ä¸ºç°åº¦
    if color.red == color.green && color.green == color.blue {
      grayscale_count = grayscale_count + 1
    }

    // æ£€æŸ¥æ˜¯å¦ä¸ºåŸè‰²
    let is_primary = (color.red == 0 || color.red == 255) &&
      (color.green == 0 || color.green == 255) &&
      (color.blue == 0 || color.blue == 255)
    if is_primary {
      primary_count = primary_count + 1
    }
  }
  println("   ğŸ“Š é¢œè‰²ç»Ÿè®¡:")
  println("      - ç°åº¦é¢œè‰²: " + grayscale_count.to_string() + " ä¸ª")
  println("      - åŸè‰²ç³»: " + primary_count.to_string() + " ä¸ª")
  if grayscale_count == colors.length() {
    println("      ğŸ’¡ è¿™æ˜¯ä¸€ä¸ªç°åº¦å›¾åƒ")
  } else if primary_count > colors.length() / 2 {
    println("      ğŸ’¡ ä¸»è¦ä½¿ç”¨åŸè‰²ç³»ï¼Œå¯èƒ½æ˜¯ç®€å•å›¾æ ‡")
  }
}

///|
/// æ£€æŸ¥æ–‡ä»¶å®Œæ•´æ€§
fn check_file_integrity(gif_data : Bytes) -> Unit {
  let file_size = gif_data.length()

  // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦ä»¥trailerç»“å°¾
  if file_size > 0 && gif_data[file_size - 1].to_int() == 0x3B {
    println("   âœ… æ–‡ä»¶ç»“å°¾æ­£ç¡® (0x3B trailer)")
  } else {
    println("   âš ï¸  æ–‡ä»¶å¯èƒ½ä¸å®Œæ•´ (ç¼ºå°‘trailer)")
  }

  // æ£€æŸ¥æœ€å°æ–‡ä»¶å¤§å°
  if file_size >= 14 { // æœ€å°GIFæ–‡ä»¶å¤§å°
    println("   âœ… æ–‡ä»¶å¤§å°ç¬¦åˆGIFæ ¼å¼è¦æ±‚")
  } else {
    println("   âŒ æ–‡ä»¶å¤§å°è¿‡å°")
  }

  // ç»™å‡ºæ–‡ä»¶ç±»å‹å»ºè®®
  println("")
  println("ğŸ’¡ å»ºè®®:")
  match file_size {
    s if s < 1024 =>
      println("   - è¿™æ˜¯ä¸€ä¸ªéå¸¸å°çš„GIFæ–‡ä»¶ï¼Œå¯èƒ½æ˜¯ç®€å•å›¾æ ‡")
    s if s < 10240 =>
      println(
        "   - è¿™æ˜¯ä¸€ä¸ªå°å‹GIFæ–‡ä»¶ï¼Œé€‚åˆä½œä¸ºå›¾æ ‡æˆ–ç®€å•åŠ¨ç”»",
      )
    s if s < 102400 => println("   - è¿™æ˜¯ä¸€ä¸ªä¸­ç­‰å¤§å°çš„GIFæ–‡ä»¶")
    s if s < 1048576 =>
      println("   - è¿™æ˜¯ä¸€ä¸ªè¾ƒå¤§çš„GIFæ–‡ä»¶ï¼Œå¯èƒ½åŒ…å«å¤æ‚åŠ¨ç”»")
    _ =>
      println("   - è¿™æ˜¯ä¸€ä¸ªå¾ˆå¤§çš„GIFæ–‡ä»¶ï¼ŒåŠ è½½å¯èƒ½éœ€è¦æ—¶é—´")
  }
}

///|
/// è¿è¡Œå®Œæ•´æ¼”ç¤ºç¨‹åº
fn run_full_demo() -> Unit {
  // æ£€æŸ¥æ˜¯å¦æœ‰é»˜è®¤çš„æ¼”ç¤ºæ–‡ä»¶
  let demo_file = "gif/__Attack.gif"
  if @fs.path_exists(demo_file) {
    println("ğŸ¯ å‘ç°æ¼”ç¤ºæ–‡ä»¶ï¼Œå°†è¿›è¡Œåˆ†æ...")
    analyze_gif_file(demo_file)
    println("")
  }
  println("ğŸª è¿è¡Œå®Œæ•´åŠŸèƒ½æ¼”ç¤º")
  println("==================================================")

  // æ¼”ç¤ºä»£ç 
  demo_gif_parsing()
  test_basic_functions()
  demo_error_handling()
  advanced_verification()
  demo_extension_analysis()
  demo_performance_benchmarks()
  println("")
  println("âœ… æ¼”ç¤ºå®Œæˆï¼")
  println("")
  println(
    "ğŸ’¡ æç¤º: ä¸‹æ¬¡å¯ä»¥ç›´æ¥æŒ‡å®šæ–‡ä»¶è·¯å¾„æ¥åˆ†æç‰¹å®šçš„GIFæ–‡ä»¶",
  )
  println("   ä¾‹å¦‚: moon run src/main your_image.gif")
}

///|
/// æ¼”ç¤ºæ‰©å±•åˆ†æ
fn demo_extension_analysis() -> Unit {
  println("\nğŸ§© 5. æ‰©å±•å—åˆ†ææ¼”ç¤º")
  println("------------------------------")

  // æµ‹è¯•ç»“æ„åˆ†æåŠŸèƒ½
  println("ğŸ” GIFç»“æ„åˆ†æ:")
  let complex_gif = create_gif_with_extensions()
  match @gif_decoder_lib.analyze_gif_structure(complex_gif) {
    Ok(analysis) => {
      let lines = analysis.split("\n")
      for line in lines {
        println("   " + line.to_string())
      }
    }
    Err(msg) => println("   âŒ åˆ†æå¤±è´¥: " + msg)
  }

  // æµ‹è¯•æ‰©å±•ä¿¡æ¯è§£æ
  println("\nğŸ” æ‰©å±•ä¿¡æ¯è§£æ:")
  test_extension_parsing()
}

///|
/// æ¼”ç¤ºæ€§èƒ½åŸºå‡†æµ‹è¯•
fn demo_performance_benchmarks() -> Unit {
  println("\nâš¡ 6. æ€§èƒ½åŸºå‡†æµ‹è¯•")
  println("------------------------------")

  // åˆ›å»ºä¸åŒå¤§å°çš„æµ‹è¯•æ•°æ®
  let test_cases = [
    ("å°æ–‡ä»¶", create_minimal_gif()),
    ("ä¸­ç­‰æ–‡ä»¶", create_complete_gif()),
    ("å¤§æ–‡ä»¶", create_large_test_gif()),
  ]
  for i = 0; i < test_cases.length(); i = i + 1 {
    let (name, data) = test_cases[i]
    println("ğŸƒ " + name + " (" + data.length().to_string() + " å­—èŠ‚):")

    // æµ‹è¯•åŸºç¡€è§£ç æ€§èƒ½
    let iterations = 100
    let mut success_count = 0
    for j = 0; j < iterations; j = j + 1 {
      match @gif_decoder_lib.decode_gif_basic(data) {
        Ok(_) => success_count = success_count + 1
        Err(_) => ()
      }
    }
    println(
      "   - åŸºç¡€è§£ç æˆåŠŸç‡: " +
      success_count.to_string() +
      "/" +
      iterations.to_string(),
    )

    // æµ‹è¯•å®Œæ•´è§£ç 
    match @gif_decoder_lib.decode_gif_complete(data) {
      Ok(_) => println("   - å®Œæ•´è§£ç : âœ… æˆåŠŸ")
      Err(msg) => println("   - å®Œæ•´è§£ç : âŒ " + msg)
    }
  }
}

///|
/// æµ‹è¯•æ‰©å±•è§£æ
fn test_extension_parsing() -> Unit {
  let extensions = [
    (
      "æ³¨é‡Šæ‰©å±•",
      Bytes::from_array([0x21, 0xFE, 5, 72, 101, 108, 108, 111, 0]),
    ),
    (
      "åº”ç”¨æ‰©å±•",
      Bytes::from_array([0x21, 0xFF, 8, 78, 69, 84, 83, 67, 65, 80, 69, 0]),
    ),
    (
      "å›¾å½¢æ§åˆ¶æ‰©å±•",
      Bytes::from_array([0x21, 0xF9, 4, 0x04, 0x64, 0x00, 0x01, 0]),
    ),
  ]
  for i = 0; i < extensions.length(); i = i + 1 {
    let (name, data) = extensions[i]
    match @gif_decoder_lib.parse_extension_info(data, 0) {
      Ok((ext_type, offset)) =>
        println(
          "   âœ… " +
          name +
          ": " +
          ext_type +
          " (åç§»: " +
          offset.to_string() +
          ")",
        )
      Err(msg) => println("   âŒ " + name + ": " + msg)
    }
  }
}

///|
/// åˆ›å»ºåŒ…å«æ‰©å±•çš„GIF
fn create_gif_with_extensions() -> Bytes {
  Bytes::from_array([
    // GIF Header
    71, 73, 70, 56, 57, 97, // "GIF89a"

    // Logical Screen Descriptor
     16, 0, 16, 0, // 16x16
     0x80, 0, 0, // Global color table

    // Global Color Table
     0, 0, 0, // Black
     255, 255, 255, // White

    // Application Extension
     0x21, 0xFF, // Extension + Application label
     11, // Block size
     78, 69, 84, 83, 67, 65, 80, 69, // "NETSCAPE"
     50, 46, 48, // "2.0"
     3, // Data sub-block size
     1, 0, 0, // Loop count
     0, // Block terminator

    // Comment Extension
     0x21, 0xFE, // Extension + Comment label
     5, // Block size
     72, 101, 108, 108, 111, // "Hello"
     0, // Block terminator

    // Image Descriptor
     0x2C, // Image separator
     0, 0, 0, 0, // Position
     8, 0, 8, 0, // 8x8 size
     0, // No local color table

    // Image Data
     2, // LZW minimum code size
     4, // Data block size
     4, 16, 24, 5, // Simple LZW data
     0, // Block terminator

    // Trailer
     0x3B,
  ])
}

///|
/// é«˜çº§éªŒè¯æµ‹è¯•
fn advanced_verification() -> Unit {
  println("\nğŸš€ 4. é«˜çº§éªŒè¯æµ‹è¯•")
  println("------------------------------")

  // æµ‹è¯•æœ€å°æœ‰æ•ˆGIF
  println("ğŸ”¬ æœ€å°GIFæ–‡ä»¶æµ‹è¯•:")
  let minimal_gif = create_minimal_gif()
  match @gif_decoder_lib.decode_gif_complete(minimal_gif) {
    Ok(result) => println("   âœ… æˆåŠŸ: " + result)
    Err(msg) => println("   âŒ å¤±è´¥: " + msg)
  }

  // æµ‹è¯•è¾ƒå¤§çš„GIF
  println("\nğŸ”¬ è¾ƒå¤§GIFæ–‡ä»¶æµ‹è¯•:")
  let large_gif = create_large_test_gif()
  match @gif_decoder_lib.parse_gif_info(large_gif) {
    Ok(info) => {
      println("   âœ… è§£ææˆåŠŸ:")
      println(
        "      - å°ºå¯¸: " +
        info.width.to_string() +
        "x" +
        info.height.to_string(),
      )
      println("      - é¢œè‰²æ•°: " + info.global_color_table_size.to_string())
    }
    Err(msg) => println("   âŒ è§£æå¤±è´¥: " + msg)
  }

  // å­—èŠ‚åºæµ‹è¯•
  println("\nğŸ”¬ å­—èŠ‚åºè½¬æ¢æµ‹è¯•:")
  test_byte_order()

  // è¾¹ç•Œæ¡ä»¶æµ‹è¯•
  println("\nğŸ”¬ è¾¹ç•Œæ¡ä»¶æµ‹è¯•:")
  test_boundary_conditions()
}

///|
/// æµ‹è¯•è¾¹ç•Œæ¡ä»¶
fn test_boundary_conditions() -> Unit {
  // æµ‹è¯•é›¶å°ºå¯¸å›¾åƒ
  let zero_size = Bytes::from_array([
    71, 73, 70, 56, 55, 97, // "GIF87a"
     0, 0, 0, 0, // 0x0 size
     0, 0, 0,
  ])
  match @gif_decoder_lib.parse_gif_info(zero_size) {
    Ok(info) =>
      println(
        "   âœ… é›¶å°ºå¯¸è§£æ: " +
        info.width.to_string() +
        "x" +
        info.height.to_string(),
      )
    Err(msg) => println("   âŒ é›¶å°ºå¯¸è§£æå¤±è´¥: " + msg)
  }

  // æµ‹è¯•æœ€å¤§å°ºå¯¸
  let max_size = Bytes::from_array([
    71, 73, 70, 56, 57, 97, // "GIF89a"
     255, 255, 255, 255, // 65535x65535
     0, 0, 0,
  ])
  match @gif_decoder_lib.parse_gif_info(max_size) {
    Ok(info) =>
      println(
        "   âœ… æœ€å¤§å°ºå¯¸è§£æ: " +
        info.width.to_string() +
        "x" +
        info.height.to_string(),
      )
    Err(msg) => println("   âŒ æœ€å¤§å°ºå¯¸è§£æå¤±è´¥: " + msg)
  }
}

///|
/// æ¼”ç¤ºGIFè§£æåŠŸèƒ½
fn demo_gif_parsing() -> Unit {
  println("\nğŸ“‹ 1. GIFæ–‡ä»¶è§£ææ¼”ç¤º")
  println("------------------------------")

  // åˆ›å»ºä¸€ä¸ªå®Œæ•´çš„æ¨¡æ‹ŸGIFæ–‡ä»¶æ•°æ®
  let gif_data = create_sample_gif()

  // åŸºç¡€è§£ç 
  println("ğŸ” åŸºç¡€è§£ç :")
  match @gif_decoder_lib.decode_gif_basic(gif_data) {
    Ok(result) => println("   " + result)
    Err(msg) => println("   é”™è¯¯: " + msg)
  }

  // è¯¦ç»†ä¿¡æ¯è§£æ
  println("\nğŸ“Š è¯¦ç»†ä¿¡æ¯è§£æ:")
  match @gif_decoder_lib.parse_gif_info(gif_data) {
    Ok(info) => {
      println("   ç‰ˆæœ¬: " + info.version)
      println(
        "   å°ºå¯¸: " + info.width.to_string() + "x" + info.height.to_string(),
      )
      println(
        "   å…¨å±€é¢œè‰²è¡¨: " +
        (if info.has_global_color_table { "æ˜¯" } else { "å¦" }),
      )
      if info.has_global_color_table {
        println("   é¢œè‰²æ•°é‡: " + info.global_color_table_size.to_string())
        println(
          "   é¢œè‰²åˆ†è¾¨ç‡: " + info.color_resolution.to_string() + " ä½",
        )
      }
      println(
        "   æ’åºæ ‡å¿—: " + (if info.sort_flag { "æ˜¯" } else { "å¦" }),
      )
      println("   èƒŒæ™¯é¢œè‰²ç´¢å¼•: " + info.bg_color_index.to_string())
      println("   åƒç´ å®½é«˜æ¯”: " + info.pixel_aspect_ratio.to_string())
    }
    Err(msg) => println("   é”™è¯¯: " + msg)
  }

  // å®Œæ•´è§£ç ï¼ˆåŒ…æ‹¬å›¾åƒä¿¡æ¯ï¼‰
  println("\nğŸ–¼ï¸ å®Œæ•´è§£ç :")
  let complete_gif = create_complete_gif()
  match @gif_decoder_lib.decode_gif_complete(complete_gif) {
    Ok(result) => println("   " + result)
    Err(msg) => println("   é”™è¯¯: " + msg)
  }
}

///|
/// æµ‹è¯•åŸºç¡€åŠŸèƒ½
fn test_basic_functions() -> Unit {
  println("\nğŸ§ª 2. åŸºç¡€åŠŸèƒ½æµ‹è¯•")
  println("------------------------------")

  // æµ‹è¯•å­—èŠ‚å·¥å…·
  println("ğŸ”§ å­—èŠ‚å·¥å…·æµ‹è¯•:")
  let b1 = (0x34).to_byte()
  let b2 = (0x12).to_byte()
  let u16_value = @gif_decoder_lib.to_u16_le(b1, b2)
  println(
    "   å°ç«¯åºè½¬æ¢: 0x" +
    b1.to_int().to_string() +
    " 0x" +
    b2.to_int().to_string() +
    " -> " +
    u16_value.to_string(),
  )

  // åŸºç¡€è§£ç å™¨æµ‹è¯•
  println("\nğŸ§ª è§£ç å™¨åŸºç¡€æµ‹è¯•:")
  let test_data = @gif_decoder_lib.create_test_gif_data()
  match @gif_decoder_lib.decode_gif_basic(test_data) {
    Ok(result) => println("   âœ… æµ‹è¯•GIFè§£ç æˆåŠŸ: " + result)
    Err(msg) => println("   âŒ æµ‹è¯•GIFè§£ç å¤±è´¥: " + msg)
  }
}

///|
/// æ¼”ç¤ºé”™è¯¯å¤„ç†
fn demo_error_handling() -> Unit {
  println("\nâŒ 3. é”™è¯¯å¤„ç†æ¼”ç¤º")
  println("------------------------------")

  // æµ‹è¯•æ— æ•ˆæ–‡ä»¶
  println("ğŸš« æ— æ•ˆæ–‡ä»¶æµ‹è¯•:")
  let invalid_data = Bytes::from_array([1, 2, 3, 4, 5])
  match @gif_decoder_lib.decode_gif_basic(invalid_data) {
    Ok(result) => println("   æ„å¤–æˆåŠŸ: " + result)
    Err(msg) => println("   âœ“ æ­£ç¡®æ£€æµ‹åˆ°é”™è¯¯: " + msg)
  }

  // æµ‹è¯•æ–‡ä»¶å¤ªå°
  println("\nğŸš« æ–‡ä»¶å¤ªå°æµ‹è¯•:")
  let tiny_data = Bytes::from_array([71, 73, 70]) // åªæœ‰ "GIF"
  match @gif_decoder_lib.parse_gif_info(tiny_data) {
    Ok(_) => println("   æ„å¤–æˆåŠŸ")
    Err(msg) => println("   âœ“ æ­£ç¡®æ£€æµ‹åˆ°é”™è¯¯: " + msg)
  }

  // æµ‹è¯•é”™è¯¯ç‰ˆæœ¬
  println("\nğŸš« é”™è¯¯ç‰ˆæœ¬æµ‹è¯•:")
  let wrong_version = Bytes::from_array([
    71, 73, 70, 57, 57, 97, // "GIF99a" - æ— æ•ˆç‰ˆæœ¬
     10, 0, 10, 0, 0, 0, 0,
  ])
  match @gif_decoder_lib.decode_gif_basic(wrong_version) {
    Ok(_) => println("   æ„å¤–æˆåŠŸ")
    Err(msg) => println("   âœ“ æ­£ç¡®æ£€æµ‹åˆ°é”™è¯¯: " + msg)
  }

  // æµ‹è¯•æŸåçš„é¢œè‰²è¡¨
  println("\nğŸš« æŸåé¢œè‰²è¡¨æµ‹è¯•:")
  let corrupted_color_table = Bytes::from_array([
    71, 73, 70, 56, 57, 97, // "GIF89a"
     10, 0, 10, 0, // 10x10
     0x80, // æœ‰å…¨å±€é¢œè‰²è¡¨ä½†æ•°æ®ä¸è¶³
     0, 0,
    // ç¼ºå°‘é¢œè‰²è¡¨æ•°æ®
  ])
  match
    @gif_decoder_lib.parse_global_color_table(corrupted_color_table, 13, 2) {
    Ok(_) => println("   æ„å¤–æˆåŠŸ")
    Err(msg) => println("   âœ“ æ­£ç¡®æ£€æµ‹åˆ°é¢œè‰²è¡¨é”™è¯¯: " + msg)
  }
}

///|
/// åˆ›å»ºç¤ºä¾‹GIFæ•°æ®
fn create_sample_gif() -> Bytes {
  Bytes::from_array([
      // GIFæ–‡ä»¶å¤´
      71, 73, 70, 56, 57, 97, // "GIF89a"

      // é€»è¾‘å±å¹•æè¿°ç¬¦
       64, 0, // å®½åº¦ = 64
       48, 0, // é«˜åº¦ = 48
       0xF0, // packed: å…¨å±€é¢œè‰²è¡¨=1, åˆ†è¾¨ç‡=7, æ’åº=0, å¤§å°=0 (2è‰²)
       0, // èƒŒæ™¯é¢œè‰²ç´¢å¼• = 0
       0,
    ], // åƒç´ å®½é«˜æ¯” = 0
  )
}

///|
/// åˆ›å»ºåŒ…å«å›¾åƒçš„å®Œæ•´GIFæ•°æ®
fn create_complete_gif() -> Bytes {
  Bytes::from_array([
    // GIFæ–‡ä»¶å¤´
    71, 73, 70, 56, 57, 97, // "GIF89a"

    // é€»è¾‘å±å¹•æè¿°ç¬¦  
     32, 0, // å®½åº¦ = 32
     32, 0, // é«˜åº¦ = 32
     0x80, // packed: å…¨å±€é¢œè‰²è¡¨=1, åˆ†è¾¨ç‡=0, æ’åº=0, å¤§å°=0 (2è‰²)
     0, // èƒŒæ™¯é¢œè‰²ç´¢å¼•
     0, // åƒç´ å®½é«˜æ¯”

    // å…¨å±€é¢œè‰²è¡¨ (2è‰²)
     0, 0, 0, // é»‘è‰²
     255, 255, 255, // ç™½è‰²

    // å›¾åƒæè¿°ç¬¦
     0x2C, // å›¾åƒåˆ†éš”ç¬¦
     0, 0, // left = 0
     0, 0, // top = 0  
     16, 0, // width = 16
     16, 0, // height = 16
     0x00, // packed: æ— å±€éƒ¨é¢œè‰²è¡¨, éäº¤é”™

    // LZWæœ€å°ä»£ç å¤§å°
     2,

    // å›¾åƒæ•°æ® (ç®€åŒ–çš„æ•°æ®å—)
     4, // æ•°æ®å—å¤§å° = 4
     0x04, 0x10, 0x18, 0x28, // ç®€å•çš„LZWå‹ç¼©æ•°æ®
     0, // æ•°æ®å—ç»ˆæ­¢ç¬¦

    // GIFæ–‡ä»¶ç»ˆæ­¢ç¬¦
     0x3B,
  ])
}

///|
/// åˆ›å»ºæœ€å°çš„æœ‰æ•ˆGIFæ–‡ä»¶
fn create_minimal_gif() -> Bytes {
  Bytes::from_array([
    // GIF Header
    0x47, 0x49, 0x46, 0x38, 0x39, 0x61, // "GIF89a"

    // Logical Screen Descriptor
     0x01, 0x00, // Width = 1
     0x01, 0x00, // Height = 1  
     0x80, // Global Color Table Flag = 1
     0x00, // Background Color Index = 0
     0x00, // Pixel Aspect Ratio = 0

    // Global Color Table (2 colors)
     0x00, 0x00, 0x00, // Color 0: Black
     0xFF, 0xFF, 0xFF, // Color 1: White

    // Image Descriptor
     0x2C, // Image Separator
     0x00, 0x00, // Left = 0
     0x00, 0x00, // Top = 0
     0x01, 0x00, // Width = 1
     0x01, 0x00, // Height = 1
     0x00, // Packed = 0

    // Image Data
     0x02, // LZW Minimum Code Size = 2
     0x02, // Data Sub-block size = 2
     0x04, 0x01, // LZW Data
     0x00, // Data Sub-block Terminator

    // GIF Trailer
     0x3B,
  ])
}

///|
/// åˆ›å»ºè¾ƒå¤§çš„æµ‹è¯•GIF
fn create_large_test_gif() -> Bytes {
  Bytes::from_array([
    // GIF Header
    0x47, 0x49, 0x46, 0x38, 0x39, 0x61, // "GIF89a"

    // Logical Screen Descriptor  
     0x10, 0x00, // Width = 16
     0x10, 0x00, // Height = 16
     0x91, // Global Color Table, 4 colors
     0x00, // Background = 0
     0x00, // Pixel Aspect Ratio = 0

    // Global Color Table (4 colors)
     0x00, 0x00, 0x00, // Black
     0xFF, 0x00, 0x00, // Red  
     0x00, 0xFF, 0x00, // Green
     0x00, 0x00, 0xFF, // Blue

    // Image Descriptor
     0x2C, // Image Separator
     0x00, 0x00, // Left = 0
     0x00, 0x00, // Top = 0
     0x08, 0x00, // Width = 8
     0x08, 0x00, // Height = 8
     0x00, // No local color table

    // Image Data
     0x02, // LZW min code size = 2
     0x08, // Data block size = 8
     0x04, 0x10, 0x18, 0x28, 0x30, 0x38, 0x40, 0x05, // LZW data
     0x00, // Data block terminator
     0x3B, // GIF Trailer
  ])
}

///|
/// æµ‹è¯•å­—èŠ‚åºè½¬æ¢
fn test_byte_order() -> Unit {
  println("   æµ‹è¯•å°ç«¯åºè½¬æ¢:")

  // æµ‹è¯•å‡ ä¸ªå€¼
  let test_cases = [
    (0x00, 0x01, 256), // 0x0100 = 256
    (0xFF, 0x00, 255), // 0x00FF = 255  
    (0x34, 0x12, 4660), // 0x1234 = 4660
    (0xCD, 0xAB, 43981), // 0xABCD = 43981
  ]
  for i = 0; i < test_cases.length(); i = i + 1 {
    let (b1, b2, expected) = test_cases[i]
    let result = @gif_decoder_lib.to_u16_le(b1.to_byte(), b2.to_byte())
    let status = if result == expected { "âœ…" } else { "âŒ" }
    println(
      "      " +
      status +
      " 0x" +
      b1.to_string() +
      " 0x" +
      b2.to_string() +
      " -> " +
      result.to_string() +
      " (æœŸæœ›: " +
      expected.to_string() +
      ")",
    )
  }
}
