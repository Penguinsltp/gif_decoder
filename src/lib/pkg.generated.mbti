// Generated using `moon info`, DON'T EDIT IT
package "Penguinsltp/gif_decoder/src/lib"

import(
  "moonbitlang/core/list"
)

// Values
fn analyze_gif_structure(Bytes) -> Result[String, String]

let application_extension_label : Byte

fn apply_color_table(@list.List[Byte], @list.List[ColorTableEntry], Int?) -> @list.List[RgbaColor]

fn apply_disposal_method(Canvas, Canvas?, Int) -> Canvas

fn apply_disposal_method_to_canvas(Canvas, Canvas?, DisposalMethod, Int, Int, Int, Int) -> Canvas

fn apply_graphic_control(Canvas, GraphicControlExtension, @list.List[Byte], @list.List[ColorTableEntry], ImageDescriptor) -> Result[Canvas, GifError]

fn bytes_to_string(Bytes, Int, Int) -> String

fn calculate_color_table_size(Int) -> Int

fn color_entry_to_rgba(ColorTableEntry, Int) -> RgbaColor

let comment_label : Byte

fn create_color_entry(Int, Int, Int) -> ColorTableEntry

fn create_color_table_entry(Int, Int, Int) -> ColorTableEntry

fn create_default_image_descriptor(Int, Int) -> ImageDescriptor

fn create_default_logical_screen(Int, Int) -> LogicalScreenDescriptor

fn create_disposal_method(Int) -> DisposalMethod

fn create_frame(ImageData, @list.List[ColorTableEntry]?, GraphicControlExtension?, Int, Int) -> Result[ImageFrame, GifError]

fn create_gif_data_blocks() -> @list.List[GifDataBlock]

fn create_gif_header(String) -> GifHeader

fn create_image_data(ImageDesc, @list.List[Byte]) -> ImageData

fn create_rgba_color(Int, Int, Int, Int) -> RgbaColor

fn create_test_gif_data() -> Bytes

fn decode_gif_basic(Bytes) -> Result[String, String]

fn decode_gif_complete(Bytes) -> Result[String, String]

fn decode_lzw(@list.List[Byte], Int) -> Result[@list.List[Byte], GifError]

fn decode_lzw_from_array(Array[Int], Int) -> Result[Array[Int], GifError]

let disposal_keep : Int

let disposal_none : Int

let disposal_restore_background : Int

let disposal_restore_previous : Int

let extension_introducer : Byte

fn extract_animation_info(Gif) -> AnimationInfo

fn fast_clear_region(Canvas, Int, Int, Int, Int, RgbaColor) -> Unit

fn find_image_descriptor(Bytes, Int) -> Result[Int, String]

fn get_color_table_size_from_descriptor(LogicalScreenDescriptor) -> Int

fn get_effective_color_table(ImageData, @list.List[ColorTableEntry]?) -> @list.List[ColorTableEntry]?

fn get_local_color_table_size(ImageDescriptor) -> Int

let gif_signature : String

let gif_version_87a : String

let gif_version_89a : String

let graphic_control_label : Byte

fn has_global_color_table(LogicalScreenDescriptor) -> Bool

fn has_local_color_table(ImageDescriptor) -> Bool

let image_separator : Byte

fn is_valid_disposal_method(Int) -> Bool

let lzw_clear_code : Int

let lzw_end_code : Int

let lzw_first_code : Int

let lzw_max_code_size : Int

fn merge_color_tables(@list.List[ColorTableEntry]?, @list.List[ColorTableEntry]?, Int) -> @list.List[ColorTableEntry]

fn new(@list.List[Byte]) -> BitReader

fn pack_image_packed_field(Bool, Bool, Bool, Int) -> Int

fn pack_logical_screen_packed_field(Bool, Int, Bool, Int) -> Int

fn parse_extension_info(Bytes, Int) -> Result[(String, Int), String]

fn parse_gif_info(Bytes) -> Result[GifInfo, String]

fn parse_global_color_table(Bytes, Int, Int) -> Result[Array[ColorEntry], String]

fn parse_image_descriptor(Bytes, Int) -> Result[(ImageDesc, Int), String]

let plain_text_label : Byte

fn render_all_frames(Gif) -> Result[@list.List[ImageFrame], GifError]

fn render_frame_to_canvas(Canvas, ImageData, @list.List[ColorTableEntry], Int?) -> Result[Unit, GifError]

fn render_pixels_to_canvas(Canvas, @list.List[RgbaColor], ImageDescriptor) -> Result[Canvas, GifError]

fn test_all_type_constructions() -> Result[String, GifError]

fn to_int8(Byte) -> Int

fn to_u16_le(Byte, Byte) -> Int

let trailer : Byte

fn unpack_image_packed_field(Int) -> (Bool, Bool, Bool, Int)

fn unpack_logical_screen_packed_field(Int) -> (Bool, Int, Bool, Int)

fn validate_dimensions(Int, Int) -> Result[Unit, GifError]

fn validate_gif_header(GifHeader) -> Result[Unit, GifError]

fn validate_graphic_control(GraphicControlExtension) -> Result[Unit, GifError]

fn validate_image_descriptor(ImageDescriptor) -> Result[Unit, GifError]

fn validate_logical_screen(LogicalScreenDescriptor) -> Result[Unit, GifError]

// Errors

// Types and methods
pub struct AnimationController {
  frames : @list.List[ImageFrame]
  image_descriptors : @list.List[ImageDescriptor]
  state : AnimationState
}
fn AnimationController::current_frame(Self) -> ImageFrame?
fn AnimationController::get_current_pixels(Self) -> Array[RgbaColor]?
fn AnimationController::is_finished(Self) -> Bool
fn AnimationController::new(@list.List[ImageFrame], @list.List[ImageDescriptor], Int, Int, Int) -> Self
fn AnimationController::output(Self, &Logger) -> Unit // from trait `Show`
fn AnimationController::reset(Self) -> Unit
fn AnimationController::to_string(Self) -> String // from trait `Show`
fn AnimationController::update(Self, Int) -> Bool
impl Show for AnimationController

pub struct AnimationInfo {
  loop_count : Int
  background_color_index : Int
  pixel_aspect_ratio : Int
}
fn AnimationInfo::output(Self, &Logger) -> Unit // from trait `Show`
fn AnimationInfo::to_string(Self) -> String // from trait `Show`
impl Show for AnimationInfo

pub struct AnimationState {
  mut current_frame : Int
  mut accumulated_time : Int
  total_frames : Int
  mut played_loops : Int
  loop_count : Int
  renderer : CanvasRenderer?
}
fn AnimationState::output(Self, &Logger) -> Unit // from trait `Show`
fn AnimationState::to_string(Self) -> String // from trait `Show`
impl Show for AnimationState

pub struct ApplicationExtension {
  application_identifier : String
  application_auth_code : String
  application_data : @list.List[Byte]
}
fn ApplicationExtension::output(Self, &Logger) -> Unit // from trait `Show`
fn ApplicationExtension::to_string(Self) -> String // from trait `Show`
impl Show for ApplicationExtension

pub struct BitReader {
  data : @list.List[Byte]
  current_byte : Byte
  bit_offset : Int
  bits_consumed : Int
  initialized : Bool
}
fn BitReader::read_bits(Self, Int) -> (Self, Int?)

pub struct Canvas {
  width : Int
  height : Int
  pixels : Array[RgbaColor]
  background_color : RgbaColor
  mut previous_frame : Array[RgbaColor]?
}
fn Canvas::apply_disposal_method(Self, Int, Int, Int, Int, Int) -> Unit
fn Canvas::clear_to_background(Self) -> Unit
fn Canvas::new(Int, Int, RgbaColor) -> Self
fn Canvas::output(Self, &Logger) -> Unit // from trait `Show`
fn Canvas::save_previous_frame(Self) -> Unit
fn Canvas::to_string(Self) -> String // from trait `Show`
impl Show for Canvas

pub struct CanvasRenderer {
  canvas : Canvas
  mut previous_disposal : Int
  mut previous_bounds : (Int, Int, Int, Int)
}
fn CanvasRenderer::get_canvas_pixels(Self) -> Array[RgbaColor]
fn CanvasRenderer::new(Int, Int, RgbaColor) -> Self
fn CanvasRenderer::output(Self, &Logger) -> Unit // from trait `Show`
fn CanvasRenderer::render_frame_with_disposal(Self, ImageFrame, ImageDescriptor) -> Result[Unit, GifError]
fn CanvasRenderer::to_string(Self) -> String // from trait `Show`
impl Show for CanvasRenderer

pub struct CodeReader {
  data : @list.List[Byte]
  mut bit_buffer : Int
  mut bit_count : Int
  mut byte_index : Int
}
fn CodeReader::new(@list.List[Byte]) -> Self
fn CodeReader::read_code(Self, Int) -> Int?

pub struct ColorEntry {
  red : Int
  green : Int
  blue : Int
}
fn ColorEntry::equal(Self, Self) -> Bool // from trait `Eq`
#deprecated
fn ColorEntry::op_equal(Self, Self) -> Bool // from trait `Eq`
fn ColorEntry::output(Self, &Logger) -> Unit // from trait `Show`
fn ColorEntry::to_string(Self) -> String // from trait `Show`
impl Eq for ColorEntry
impl Show for ColorEntry

pub struct ColorTableEntry {
  red : Int
  green : Int
  blue : Int
}
fn ColorTableEntry::equal(Self, Self) -> Bool // from trait `Eq`
#deprecated
fn ColorTableEntry::op_equal(Self, Self) -> Bool // from trait `Eq`
fn ColorTableEntry::output(Self, &Logger) -> Unit // from trait `Show`
fn ColorTableEntry::to_string(Self) -> String // from trait `Show`
impl Eq for ColorTableEntry
impl Show for ColorTableEntry

pub struct CommentExtension {
  comment_data : @list.List[Byte]
}
fn CommentExtension::output(Self, &Logger) -> Unit // from trait `Show`
fn CommentExtension::to_string(Self) -> String // from trait `Show`
impl Show for CommentExtension

pub enum DetailedGifError {
  InvalidSignature(String)
  UnsupportedVersion(String)
  InvalidBlockSize(Int)
  InvalidLzwMinimumCodeSize(Int)
  InvalidColorTableSize(Int)
  ImageTooLarge(Int, Int)
  InvalidDisposalMethod(Int)
  CorruptedSubBlock
}
fn DetailedGifError::output(Self, &Logger) -> Unit // from trait `Show`
fn DetailedGifError::to_string(Self) -> String // from trait `Show`
impl Show for DetailedGifError

pub enum DisposalMethod {
  None
  DoNotDispose
  RestoreToBackground
  RestoreToPrevious
}
fn DisposalMethod::equal(Self, Self) -> Bool // from trait `Eq`
#deprecated
fn DisposalMethod::op_equal(Self, Self) -> Bool // from trait `Eq`
fn DisposalMethod::output(Self, &Logger) -> Unit // from trait `Show`
fn DisposalMethod::to_string(Self) -> String // from trait `Show`
impl Eq for DisposalMethod
impl Show for DisposalMethod

pub enum ExtensionType {
  PlainText(PlainTextExtension)
  GraphicControl(GraphicControlExtension)
  Comment(CommentExtension)
  Application(ApplicationExtension)
}
fn ExtensionType::output(Self, &Logger) -> Unit // from trait `Show`
fn ExtensionType::to_string(Self) -> String // from trait `Show`
impl Show for ExtensionType

pub struct Gif {
  header : GifHeader
  logical_screen : LogicalScreenDescriptor
  global_color_table : @list.List[ColorTableEntry]?
  data_blocks : @list.List[GifDataBlock]
}
fn Gif::output(Self, &Logger) -> Unit // from trait `Show`
fn Gif::to_string(Self) -> String // from trait `Show`
impl Show for Gif

pub enum GifDataBlock {
  Extension(ExtensionType)
  Image(ImageData)
  Trailer
}
fn GifDataBlock::output(Self, &Logger) -> Unit // from trait `Show`
fn GifDataBlock::to_string(Self) -> String // from trait `Show`
impl Show for GifDataBlock

pub enum GifError {
  InvalidHeader
  InvalidLogicalScreen
  InvalidColorTable
  InvalidImageDescriptor
  InvalidExtension
  InvalidFormat
  LzwDecodingError
  NoColorTable
  UnsupportedFeature
  DataCorrupted
  UnexpectedEndOfFile
  InvalidBlockSize(Int)
}
fn GifError::output(Self, &Logger) -> Unit // from trait `Show`
fn GifError::to_string(Self) -> String // from trait `Show`
impl Show for GifError

pub struct GifHeader {
  signature : String
  version : String
}
fn GifHeader::output(Self, &Logger) -> Unit // from trait `Show`
fn GifHeader::to_string(Self) -> String // from trait `Show`
impl Show for GifHeader

pub struct GifInfo {
  version : String
  width : Int
  height : Int
  has_global_color_table : Bool
  global_color_table_size : Int
  color_resolution : Int
  sort_flag : Bool
  bg_color_index : Int
  pixel_aspect_ratio : Int
}
fn GifInfo::output(Self, &Logger) -> Unit // from trait `Show`
fn GifInfo::to_string(Self) -> String // from trait `Show`
impl Show for GifInfo

pub struct GraphicControlExtension {
  disposal_method : Int
  user_input_flag : Bool
  transparent_color_flag : Bool
  delay_time : Int
  transparent_color_index : Int
}
fn GraphicControlExtension::output(Self, &Logger) -> Unit // from trait `Show`
fn GraphicControlExtension::to_string(Self) -> String // from trait `Show`
impl Show for GraphicControlExtension

pub struct ImageData {
  descriptor : ImageDescriptor
  local_color_table : @list.List[ColorTableEntry]?
  image_data : @list.List[Byte]
}
fn ImageData::output(Self, &Logger) -> Unit // from trait `Show`
fn ImageData::to_string(Self) -> String // from trait `Show`
impl Show for ImageData

pub struct ImageDesc {
  left : Int
  top : Int
  width : Int
  height : Int
  has_local_color_table : Bool
  interlaced : Bool
  sorted : Bool
  local_color_table_size : Int
}
fn ImageDesc::output(Self, &Logger) -> Unit // from trait `Show`
fn ImageDesc::to_string(Self) -> String // from trait `Show`
impl Show for ImageDesc

pub struct ImageDescriptor {
  left : Int
  top : Int
  width : Int
  height : Int
  local_color_table_flag : Bool
  interlace_flag : Bool
  sort_flag : Bool
  local_color_table_size : Int
}
fn ImageDescriptor::output(Self, &Logger) -> Unit // from trait `Show`
fn ImageDescriptor::to_string(Self) -> String // from trait `Show`
impl Show for ImageDescriptor

pub struct ImageFrame {
  width : Int
  height : Int
  pixels : Array[RgbaColor]
  delay : Int
  disposal_method : Int
  transparent_index : Int?
}
fn ImageFrame::output(Self, &Logger) -> Unit // from trait `Show`
fn ImageFrame::to_string(Self) -> String // from trait `Show`
impl Show for ImageFrame

pub struct LogicalScreenDescriptor {
  screen_width : Int
  screen_height : Int
  global_color_table_flag : Bool
  color_resolution : Int
  sort_flag : Bool
  global_color_table_size : Int
  background_color_index : Int
  pixel_aspect_ratio : Int
}
fn LogicalScreenDescriptor::output(Self, &Logger) -> Unit // from trait `Show`
fn LogicalScreenDescriptor::to_string(Self) -> String // from trait `Show`
impl Show for LogicalScreenDescriptor

pub struct LzwDecoder {
  dictionary : Array[LzwEntry]
  mut code_size : Int
  mut clear_code : Int
  mut end_code : Int
  mut next_code : Int
  mut max_code : Int
  mut dictionary_size : Int
}
fn LzwDecoder::add_to_dictionary(Self, Int, Byte) -> Unit
fn LzwDecoder::get_first_char(Self, Int) -> Byte
fn LzwDecoder::get_string(Self, Int) -> @list.List[Byte]
fn LzwDecoder::new(Int) -> Self
fn LzwDecoder::reset_dictionary(Self, Int) -> Unit

pub struct LzwEntry {
  prefix : Int
  suffix : Byte
}

pub struct PlainTextExtension {
  text_grid_left_position : Int
  text_grid_top_position : Int
  text_grid_width : Int
  text_grid_height : Int
  character_cell_width : Int
  character_cell_height : Int
  text_foreground_color_index : Int
  text_background_color_index : Int
  plain_text_data : @list.List[Byte]
}
fn PlainTextExtension::output(Self, &Logger) -> Unit // from trait `Show`
fn PlainTextExtension::to_string(Self) -> String // from trait `Show`
impl Show for PlainTextExtension

pub struct RgbaColor {
  red : Int
  green : Int
  blue : Int
  alpha : Int
}
fn RgbaColor::equal(Self, Self) -> Bool // from trait `Eq`
#deprecated
fn RgbaColor::op_equal(Self, Self) -> Bool // from trait `Eq`
fn RgbaColor::output(Self, &Logger) -> Unit // from trait `Show`
fn RgbaColor::to_string(Self) -> String // from trait `Show`
impl Eq for RgbaColor
impl Show for RgbaColor

// Type aliases

// Traits

